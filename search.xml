<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PgSql常用命令速查表</title>
      <link href="/120a5ef339a8/pgsql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E8%A1%A8/"/>
      <url>/120a5ef339a8/pgsql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="库-表"><a href="#库-表" class="headerlink" title="库,表"></a>库,表</h1><ul><li><p>创建数据库</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> _database</span><br><span class="line"><span class="keyword">WITH</span> OWNER = postgres</span><br><span class="line">ENCODING = <span class="string">&#x27;UTF8&#x27;</span></span><br><span class="line">TABLESPACE = pg_default</span><br><span class="line">LC_COLLATE = <span class="string">&#x27;en_US.UTF-8&#x27;</span></span><br><span class="line">LC_CTYPE = <span class="string">&#x27;en_US.UTF-8&#x27;</span></span><br><span class="line">CONNECTION LIMIT = <span class="number">-1</span></span><br><span class="line"><span class="keyword">TEMPLATE</span> template0;</span><br></pre></td></tr></table></figure></li><li><p>查找当前正在访问该数据库的会话</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    pid, </span><br><span class="line">    usename, </span><br><span class="line">    application_name, </span><br><span class="line">    client_addr, </span><br><span class="line">    state </span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    pg_stat_activity </span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">    datname = <span class="string">&#x27;_database&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>终止数据库连接会话</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    pg_terminate_backend(pid) </span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">    pg_stat_activity </span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">    datname = <span class="string">&#x27;_database&#x27;</span> </span><br><span class="line">    <span class="keyword">AND</span> pid &lt;&gt; pg_backend_pid();</span><br></pre></td></tr></table></figure></li><li><p>查看表的所有索引</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> pg_indexes <span class="keyword">where</span> tablename=<span class="string">&#x27;_table_name&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>清空表数据</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> _table_name</span><br></pre></td></tr></table></figure></li><li><p>查询数据库死锁信息</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line">http://postgres.cn/docs/<span class="number">13</span>/monitoring-stats.html#MONITORING-PG-STAT-ACTIVITY-<span class="keyword">VIEW</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> pg_stat_activity <span class="keyword">where</span> wait_event_type = <span class="string">&#x27;Lock&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>查询数据库锁状态</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> pg_locks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> pg_locks pl <span class="keyword">LEFT JOIN</span> pg_stat_activity psa</span><br><span class="line"><span class="keyword">ON</span> pl.pid = psa.pid;</span><br></pre></td></tr></table></figure></li><li><p>删除死锁</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> pg_terminate_backend(<span class="string">&#x27;pid&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>查询表大小，数据大小，index，大小</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="built_in">table_name</span>,</span><br><span class="line">    pg_size_pretty(table_size) <span class="keyword">AS</span> table_size,</span><br><span class="line">    pg_size_pretty(indexes_size) <span class="keyword">AS</span> indexes_size,</span><br><span class="line">    pg_size_pretty(total_size) <span class="keyword">AS</span> total_size</span><br><span class="line">  <span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">      <span class="built_in">table_name</span>,</span><br><span class="line">      pg_table_size(<span class="built_in">table_name</span>) <span class="keyword">AS</span> table_size,</span><br><span class="line">      pg_indexes_size(<span class="built_in">table_name</span>) <span class="keyword">AS</span> indexes_size,</span><br><span class="line">      pg_total_relation_size(<span class="built_in">table_name</span>) <span class="keyword">AS</span> total_size</span><br><span class="line">    <span class="keyword">FROM</span> (</span><br><span class="line">      <span class="keyword">SELECT</span> (<span class="string">&#x27;&quot;&#x27;</span> || table_schema || <span class="string">&#x27;&quot;.&quot;&#x27;</span> || <span class="built_in">table_name</span> || <span class="string">&#x27;&quot;&#x27;</span>) <span class="keyword">AS</span> <span class="built_in">table_name</span></span><br><span class="line">        <span class="keyword">FROM</span> information_schema.<span class="keyword">tables</span></span><br><span class="line">      ) <span class="keyword">AS</span> all_tables</span><br><span class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> total_size <span class="keyword">DESC</span></span><br><span class="line">  ) <span class="keyword">AS</span> pretty_sizes;</span><br></pre></td></tr></table></figure></li><li><p>查询单表数据大小</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> pg_size_pretty(pg_relation_size(<span class="string">&#x27;_table_name&#x27;</span>));</span><br></pre></td></tr></table></figure></li><li><p>创建自增id</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">SEQUENCE</span> _table_name_field_seq <span class="keyword">START</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>设置自增id</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &quot;public&quot;.&quot;_table_name&quot;;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> &quot;id&quot; <span class="keyword">SET</span> <span class="keyword">DEFAULT</span> nextval(<span class="string">&#x27;_table_name_field_seq&#x27;</span>::<span class="type">regclass</span>);</span><br></pre></td></tr></table></figure></li><li><p>查看数据库表当前自增id</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">select</span> * <span class="keyword">from</span> _table_name_field_seq;</span><br><span class="line"></span><br><span class="line">- 修改数据库自增id</span><br><span class="line"></span><br><span class="line">  ```postgresql</span><br><span class="line">  <span class="keyword">select</span> setval(<span class="string">&#x27;_table_name_field_seq&#x27;</span>, (<span class="keyword">select</span> max(id) <span class="keyword">from</span> _table_name));</span><br></pre></td></tr></table></figure></li><li><p>给用户添加可读权限</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> _table_name <span class="keyword">TO</span> _user_name;</span><br></pre></td></tr></table></figure></li><li><p>查询数据库下面的所有用户</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> pg_user;</span><br></pre></td></tr></table></figure></li><li><p>查询数据库连接</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> pg_stat_activity;</span><br></pre></td></tr></table></figure></li><li><p>查询唯一约束</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    conname <span class="keyword">AS</span> <span class="built_in">constraint_name</span>,</span><br><span class="line">    pg_get_constraintdef(con.oid) <span class="keyword">AS</span> constraint_definition</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    pg_constraint con</span><br><span class="line"><span class="keyword">JOIN</span></span><br><span class="line">    pg_class rel <span class="keyword">ON</span> rel.oid = con.conrelid</span><br><span class="line"><span class="keyword">JOIN</span></span><br><span class="line">    pg_namespace nsp <span class="keyword">ON</span> nsp.oid = rel.relnamespace</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    con.contype = <span class="string">&#x27;u&#x27;</span></span><br><span class="line">    <span class="keyword">AND</span> nsp.nspname = <span class="string">&#x27;public&#x27;</span></span><br><span class="line">    <span class="keyword">AND</span> rel.relname = <span class="string">&#x27;user_info&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>往一张表里面批量插入自增数据</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> _table_name (_serial_field, _fix_field) <span class="keyword">SELECT</span> generate_series(<span class="number">100000</span>, <span class="number">999999</span>), <span class="number">1722581987</span>;</span><br></pre></td></tr></table></figure></li></ul><h1 id="JSONB"><a href="#JSONB" class="headerlink" title="JSONB"></a>JSONB</h1><ul><li><p>展开数组对象(jsonb_array_elements)</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> jsonb_array_elements(_field) -&gt;&gt; <span class="string">&#x27;_jsonb_key&#x27;</span> <span class="keyword">from</span> _table_name;</span><br></pre></td></tr></table></figure></li><li><p>获取对象key列表(jsonb_object_keys)</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> jsonb_object_keys(_field) <span class="keyword">from</span> _table_name;</span><br></pre></td></tr></table></figure></li><li><p>查询数据是否包含某个数据</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> _table_name <span class="keyword">where</span> (_field)::<span class="type">jsonb</span> ? <span class="string">&#x27;_target_val&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>更新jsonb的某个字段的值</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> _table_name <span class="keyword">set</span> _field = jsonb_set(_field, <span class="string">&#x27;&#123;_jsonb_key&#125;&#x27;</span>, <span class="string">&#x27;&quot;_jsonb_val&quot;&#x27;</span>) <span class="keyword">where</span>;</span><br></pre></td></tr></table></figure></li><li><p>更新多级字段</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> _table_name <span class="keyword">set</span> _field = jsonb_set(_field, <span class="string">&#x27;&#123;a, b&#125;&#x27;</span>, <span class="string">&#x27;1&#x27;</span>) <span class="keyword">where</span>;</span><br></pre></td></tr></table></figure></li><li><p>删除多个key</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> _table_name <span class="keyword">SET data</span> = data #- <span class="string">&#x27;&#123;_field01&#125;&#x27;</span> #- <span class="string">&#x27;&#123;_field02&#125;&#x27;</span> <span class="keyword">where</span>;</span><br></pre></td></tr></table></figure></li><li><p>插入多个值</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> _table_name <span class="keyword">set</span> _field = (_field||<span class="string">&#x27;&#123;&quot;a&quot;: 1, &quot;b&quot;: 2&#125;&#x27;</span>) <span class="keyword">where</span>;</span><br></pre></td></tr></table></figure></li><li><p>路径查询</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> jsonb_path_query(_field, <span class="string">&#x27;$.count_rate_cfg_list[*].open_num&#x27;</span>) <span class="keyword">from</span> _table_name;</span><br></pre></td></tr></table></figure></li><li><p>路径匹配</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> _table_name <span class="keyword">where</span> jsonb_path_match(_filed, <span class="string">&#x27;exists($.&quot;3&quot;[0].&quot;type&quot; ? (@ == 3))&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>路径存在</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> _table_name <span class="keyword">where</span> jsonb_path_exists(_field, <span class="string">&#x27;$.&quot;3&quot;[0].&quot;type&quot;&#x27;</span>) = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> _table_name <span class="keyword">where</span> jsonb_path_exists(_field, <span class="string">&#x27;$.*.&quot;openPos&quot;? (@ == 1)&#x27;</span>) = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure></li><li><p>删除多级字段</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> _table_name <span class="keyword">set</span> _field = _field::<span class="type">jsonb</span> #- <span class="string">&#x27;&#123;a,b&#125;&#x27;</span> <span class="keyword">where</span>;</span><br></pre></td></tr></table></figure></li><li><p>in查询排序</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> _table_name <span class="keyword">where</span> id <span class="keyword">in</span> (</span><br><span class="line"><span class="number">1</span>,</span><br><span class="line"><span class="number">2</span></span><br><span class="line">) <span class="keyword">order</span> <span class="keyword">by</span> array_positions(<span class="keyword">array</span>[</span><br><span class="line"><span class="number">1</span>,</span><br><span class="line"><span class="number">2</span></span><br><span class="line">], id);</span><br></pre></td></tr></table></figure></li></ul><h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><ul><li><p>计数</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> count(*) <span class="keyword">as</span> count <span class="keyword">from</span> _table_name <span class="keyword">group</span> <span class="keyword">by</span> _field <span class="keyword">HAVING</span> count(*) &gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>with</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> a <span class="keyword">as</span> (),</span><br><span class="line">b <span class="keyword">as</span> ();</span><br></pre></td></tr></table></figure></li><li><p>字符串拼接</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> _table_name <span class="keyword">set</span> _field = _field||<span class="string">&#x27;_target_val&#x27;</span> <span class="keyword">where</span>;</span><br></pre></td></tr></table></figure></li><li><p>时间戳转时间</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> to_timestamp(_field) <span class="keyword">from</span> _table_name;</span><br></pre></td></tr></table></figure></li><li><p>查询日期</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> to_char(to_timestamp(_field), <span class="string">&#x27;YYYY HH24:MI:SS&#x27;</span>), * <span class="keyword">from</span> _table_name;</span><br></pre></td></tr></table></figure></li><li><p>查询pgsql的所有时区</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> pg_timezone_names <span class="keyword">order</span> <span class="keyword">by</span> utc_offset;</span><br></pre></td></tr></table></figure></li><li><p>查询时间戳转时间字符串带时区</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> to_timestamp(<span class="number">1718917200</span>) <span class="keyword">AT TIME ZONE</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>like多个值</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> _table_name <span class="keyword">where</span> _field <span class="keyword">like</span> <span class="keyword">any</span> (<span class="keyword">array</span>[<span class="string">&#x27;%searchText1%&#x27;</span>, <span class="string">&#x27;%searchText2%&#x27;</span>]);</span><br></pre></td></tr></table></figure></li><li><p>like 排除多个</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> _table_name <span class="keyword">where</span> _field <span class="keyword">not</span> <span class="keyword">like</span> <span class="keyword">all</span> (<span class="keyword">array</span>[<span class="string">&#x27;%searchText1%&#x27;</span>, <span class="string">&#x27;%searchText2%&#x27;</span>]);</span><br></pre></td></tr></table></figure></li><li><p>错行计算</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">_field1, </span><br><span class="line">_field2, </span><br><span class="line">_field3, </span><br><span class="line">lag(_field3, <span class="number">1</span>) <span class="keyword">over</span>(<span class="keyword">PARTITION</span> <span class="keyword">by</span> _field1 <span class="keyword">order</span> <span class="keyword">by</span> _field2) </span><br><span class="line"><span class="keyword">from</span> _table_name;</span><br></pre></td></tr></table></figure></li><li><p>查询重复数据</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> (</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">_field1,</span><br><span class="line">_field2,</span><br><span class="line">row_number() <span class="keyword">over</span> (<span class="keyword">PARTITION</span> <span class="keyword">by</span> _field1 <span class="keyword">order</span> <span class="keyword">by</span> _field2 <span class="keyword">desc</span>) <span class="keyword">as</span> row_num</span><br><span class="line"><span class="keyword">from</span> _table_name</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> row_num <span class="keyword">desc</span></span><br><span class="line">) t1 <span class="keyword">where</span> t1.row_num &gt; <span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> _field2 <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li><li><p>窗口函数</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> (</span><br><span class="line">  <span class="keyword">select</span></span><br><span class="line">    _field1,</span><br><span class="line">    _field2,</span><br><span class="line">    row_number() <span class="keyword">over</span> (<span class="keyword">PARTITION</span> <span class="keyword">by</span> _field1 <span class="keyword">order</span> <span class="keyword">by</span> _field2 <span class="keyword">desc</span>) <span class="keyword">as</span> row_num</span><br><span class="line">  <span class="keyword">from</span> _table_name</span><br><span class="line">  <span class="keyword">order</span> <span class="keyword">by</span> row_num <span class="keyword">desc</span></span><br><span class="line">) t1 <span class="keyword">where</span> t1.row_num &gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>联合查询</p><figure class="highlight postgresql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> _table_name <span class="keyword">WHERE</span> _field = xxx</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> _table_name <span class="keyword">WHERE</span> _field = xxx;</span><br></pre></td></tr></table></figure></li></ul><h1 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h1><hr><p>仅供自己学习使用，如有侵权请联系删除[<a href="mailto:&#49;&#55;&#x35;&#x38;&#x35;&#x37;&#53;&#x39;&#54;&#57;&#64;&#113;&#113;&#x2e;&#x63;&#x6f;&#x6d;">&#49;&#55;&#x35;&#x38;&#x35;&#x37;&#53;&#x39;&#54;&#57;&#64;&#113;&#113;&#x2e;&#x63;&#x6f;&#x6d;</a>]。</p><hr>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
          <category> pgsql </category>
          
          <category> basics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pgsql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令速查表</title>
      <link href="/387dc896a80f/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E8%A1%A8/"/>
      <url>/387dc896a80f/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h1><ul><li><p>查看所有分支</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure></li><li><p>查看当前所在分支</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></li><li><p>删除本地分支</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -d localBranch</span><br></pre></td></tr></table></figure></li><li><p>删除远程分支</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin --delete remoteBranch/</span><br></pre></td></tr></table></figure></li><li><p>查看远程仓库地址</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure></li><li><p>取消合并</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --merge</span><br></pre></td></tr></table></figure></li><li><p>在当前分支创建本地分支</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -b branchName</span><br></pre></td></tr></table></figure></li><li><p>将创建的本地分支推送到远端</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin branchName</span><br></pre></td></tr></table></figure></li><li><p>将本地分支关联到对应远端分支</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch --set-upstream-to=origin/branchName</span><br></pre></td></tr></table></figure></li><li><p>查看本地分支和远程分支的映射关系</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -vv</span><br></pre></td></tr></table></figure></li><li><p>查看远程分支</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure></li><li><p>查看本地各个分支目前最新的提交</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -v</span><br></pre></td></tr></table></figure></li><li><p>查看远程各个分支目前最新的提交</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch -r -v</span><br></pre></td></tr></table></figure></li><li><p>本地同步远程仓库</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote prune origin</span><br></pre></td></tr></table></figure></li></ul><h1 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h1><ul><li><p>撤销从上次提交之后所做的所有修改</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -- *</span><br></pre></td></tr></table></figure></li><li><p>撤销从上次提交之后的单个文件的修改</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout -- fileName</span><br></pre></td></tr></table></figure></li><li><p>撤销commit</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git reset --soft HEAD^</span><br></pre></td></tr></table></figure></li><li><p>修改commit注释</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure></li><li><p>commit message</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">feat: 添加新特性</span><br><span class="line">fix: 修复bug</span><br><span class="line">docs: 仅仅修改了文档</span><br><span class="line">style: 仅仅修改了空格、格式缩进、逗号等等，不改变代码逻辑</span><br><span class="line">refactor: 代码重构，没有新功能或者修复bug</span><br><span class="line">perf: 优化相关，比如提升性能、体验</span><br><span class="line">test:增加测试用例</span><br><span class="line">build: 依赖相关内容</span><br><span class="line">ci: ci配置相关 例如多k8s，docker的配置文件的修改</span><br><span class="line">chore: 改变构建流程、或者增加依赖库、工具等。</span><br><span class="line">revert: 回滚到上一版本</span><br></pre></td></tr></table></figure></li></ul><h1 id="log"><a href="#log" class="headerlink" title="log"></a>log</h1><ul><li><p>关键字</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --grep targetField</span><br></pre></td></tr></table></figure></li><li><p>关键字+作者</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --grep targetField --author authorName/authorEmail</span><br></pre></td></tr></table></figure></li><li><p>关键字(一行)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --oneline | grep targetField</span><br></pre></td></tr></table></figure></li><li><p>搜索提交消息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log | grep targetFiled</span><br></pre></td></tr></table></figure></li><li><p>图像查看提交日志</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --graph --all --oneline</span><br></pre></td></tr></table></figure></li><li><p>日志log搜索统计次数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log | grep targetFiled ｜ wc -l</span><br></pre></td></tr></table></figure></li><li><p>搜索查询时间范围内的日志</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --since=&quot;2019-12-01&quot; --until=&quot;2019-12-19&quot; --oneline</span><br></pre></td></tr></table></figure></li><li><p>git日志输出</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --since=&quot;2022-10-11 00:00:00&quot; --until=&quot;2022-10-13 00:00:00&quot; &gt;&gt; fileName</span><br><span class="line">--after--before</span><br></pre></td></tr></table></figure></li><li><p>git日志搜索最近几次提交</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log -targetNum</span><br></pre></td></tr></table></figure></li><li><p>查看目标文件提交记录</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log -- fileName</span><br></pre></td></tr></table></figure></li><li><p>查看目标文件提交的详细变动</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log -p -- &lt;file&gt;</span><br></pre></td></tr></table></figure></li><li><p>查看提交文件详细内容变动过滤</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log -S&#x27;具体内容&#x27;</span><br><span class="line">git log -G&#x27;正则表达式&#x27;</span><br></pre></td></tr></table></figure></li><li><p>查看分支区间的提交</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log branchName1..branchName2</span><br></pre></td></tr></table></figure></li><li><p>统计提交日志次数</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git shortlog --numbered --summary</span><br></pre></td></tr></table></figure></li><li><p>查看提交变动文件</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git show commit_id --raw</span><br></pre></td></tr></table></figure></li><li><p>查看每一个commit之间的差异信息</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log -p</span><br></pre></td></tr></table></figure></li><li><p>查看所有提交的修改文件信息</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log --stat</span><br></pre></td></tr></table></figure></li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul><li><p>检查 Git 存储库中的完整性, 并查找任何丢失或损坏的对象</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fsck --lost-found</span><br></pre></td></tr></table></figure></li><li><p>对 Git 仓库进行垃圾收集, 并立即删除任何无法访问的松散对象</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git gc --prune=now</span><br></pre></td></tr></table></figure></li></ul><h1 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h1><hr><p>仅供自己学习使用，如有侵权请联系删除[<a href="mailto:&#x31;&#55;&#53;&#56;&#53;&#55;&#53;&#x39;&#x36;&#x39;&#64;&#113;&#113;&#46;&#99;&#x6f;&#x6d;">&#x31;&#55;&#53;&#56;&#53;&#55;&#53;&#x39;&#x36;&#x39;&#64;&#113;&#113;&#46;&#99;&#x6f;&#x6d;</a>]。</p><hr>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[鸟哥的Linux私房菜笔记] 第五章-Linux的文件权限与目录配置</title>
      <link href="/c5d058f376e6/05_Linux%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE/"/>
      <url>/c5d058f376e6/05_Linux%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="权限属性"><a href="#权限属性" class="headerlink" title="权限属性"></a>权限属性</h2><ul><li><p>拥有者(owner)</p><p>文件或目录的拥有者。通常，创建文件或目录的用户就是它的所有者。拥有者可以设置自己对文件或目录的读、写和执行权限</p></li><li><p>群组(group)</p><p>每个文件或目录都属于一个群组。群组中的成员是一个或多个用户。文件或目录的群组成员可以拥有与所有者不同的权限。通过群组权限，可以控制特定用户组对文件或目录的访问。</p></li><li><p>其他人(other)</p><p>其他人指的是系统中的其他所有用户，不包括文件或目录的所有者和群组成员。其他人权限控制了这些用户对文件或目录的访问和操作权限。</p></li></ul><h2 id="Linux文件权限概念"><a href="#Linux文件权限概念" class="headerlink" title="Linux文件权限概念"></a>Linux文件权限概念</h2><h4 id="Linux文件属性"><a href="#Linux文件属性" class="headerlink" title="Linux文件属性"></a>Linux文件属性</h4><p>使用su -切换到root身份，然后ls -al，显示文件的文件名与相关属性</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">su -</span><br><span class="line"></span><br><span class="line"><span class="built_in">ls</span> -al</span><br><span class="line"></span><br><span class="line">dr-xr-x---.  5 root root 4096 Apr 21  2021 .</span><br><span class="line">dr-xr-xr-x. 18 root root 4096 Aug  1 17:50 ..</span><br><span class="line">-rw-------   1 root root 1060 Aug  6 17:58 .bash_history</span><br><span class="line">-rw-r--r--.  1 root root   18 Dec 29  2013 .bash_logout</span><br><span class="line">-rw-r--r--.  1 root root  176 Dec 29  2013 .bash_profile</span><br><span class="line">-rw-r--r--.  1 root root  176 Dec 29  2013 .bashrc</span><br><span class="line">drwxr-xr-x   3 root root 4096 Jul 11  2019 .cache</span><br><span class="line">-rw-r--r--.  1 root root  100 Dec 29  2013 .cshrc</span><br><span class="line">drwxr-xr-x   2 root root 4096 Jul 11  2019 .pip</span><br><span class="line">-rw-r--r--   1 root root  205 Mar 12  2021 .pydistutils.cfg</span><br><span class="line">drwx------   2 root root 4096 Jul 11  2019 .ssh</span><br><span class="line">-rw-r--r--.  1 root root  129 Dec 29  2013 .tcshrc</span><br></pre></td></tr></table></figure><p>eg: .cache</p><table><thead><tr><th>drwxr-xr-x</th><th>3</th><th>root</th><th>root</th><th>4096</th><th>Jul 11  2019</th><th>.cache</th></tr></thead><tbody><tr><td>权限</td><td>连接数</td><td>拥有者</td><td>群组</td><td>文件容量</td><td>修改时间</td><td>文档名</td></tr></tbody></table><h4 id="权限解析"><a href="#权限解析" class="headerlink" title="权限解析"></a>权限解析</h4><table><thead><tr><th>第一个字符</th><th>第一组(rwx)</th><th>第二组(r-x)</th><th>第三组(r-x)</th></tr></thead><tbody><tr><td>目录、文件或链接文件</td><td>拥有者权限</td><td>群组账号权限</td><td>其他人权限</td></tr></tbody></table><ul><li><p>第一个字符</p><ul><li>“d”: 目录</li><li>“-“: 文件</li><li>“l”: 连接档(link file)</li><li>“b”: 装置文件里面的可供存储的接口设备(可随机存取装置)</li><li>“c”: 装置文件里面的串行端口设备, 例如键盘、鼠标(一次性读取装置)</li></ul></li><li><p>接下来字符三个为一组，且均为[rwx]的三个参数组合,权限位置不会改变，没有权限则减号[-]代替</p><ul><li>“r”: 可读(read)，权限分数4</li><li>“w”: 可写(write)，权限分数2</li><li>“x”: 可执行(execute)，权限分数1</li></ul><table><thead><tr><th>类型</th><th>r</th><th>w</th><th>x</th></tr></thead><tbody><tr><td>文件</td><td>读取文件内容</td><td>修改文件内容</td><td>执行文件内容</td></tr><tr><td>目录</td><td>读取目录</td><td>修改目录名称</td><td>进入该目录的权限</td></tr></tbody></table></li></ul><h4 id="Linux文件权限的重要性"><a href="#Linux文件权限的重要性" class="headerlink" title="Linux文件权限的重要性"></a>Linux文件权限的重要性</h4><ul><li>系统保护的功能</li><li>团队开发软件或数据共享的功能</li><li>未将权限设定妥当的危害</li></ul><h4 id="如何改变文件属性与权限"><a href="#如何改变文件属性与权限" class="headerlink" title="如何改变文件属性与权限"></a>如何改变文件属性与权限</h4><ul><li><p>改变所属群组</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chgrp</span> [-R] <span class="built_in">dirname</span>/filename</span><br><span class="line">  -R: 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件、目录都更新成为这个群组之意。常常用在变更某一目录内所有的文件之情况</span><br><span class="line">eg:</span><br><span class="line">  <span class="built_in">chgrp</span> <span class="built_in">users</span> example.txt</span><br></pre></td></tr></table></figure></li><li><p>改变文件拥有者</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chown</span> [-R] 账号名称 文件或目录</span><br><span class="line"><span class="built_in">chown</span> [-R] 账号名称:组名 文件或目录</span><br><span class="line">可以用.来隔开拥有者和群组，应为有些账号有小数点.,比如vbird.tsai，会造成系统误判,建议使用冒号:来隔开</span><br><span class="line">  -R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都变更</span><br><span class="line">eg:</span><br><span class="line">  将 example.txt 的拥有者改为 bin 这个账号</span><br><span class="line">    <span class="built_in">chown</span> bin example.txt</span><br><span class="line">  将 example.txt 的拥有者与群组改回为 root</span><br><span class="line">    <span class="built_in">chown</span> root:root example.txt</span><br></pre></td></tr></table></figure></li><li><p>改变权限</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> [-R] xyz 文件或目录</span><br><span class="line">  xyz : 数字类型的权限属性，为 rwx 属性数值的相加。</span><br><span class="line">  -R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更</span><br><span class="line">  </span><br><span class="line">  数字改变权限(r: 4, w: 2, x: 1)</span><br><span class="line">    [-rwxrwx---]</span><br><span class="line">      owner = rwx = 4+2+1 = 7</span><br><span class="line">      group = rwx = 4+2+1 = 7</span><br><span class="line">      others= --- = 0+0+0 = 0</span><br><span class="line">    eg:</span><br><span class="line">      <span class="built_in">chmod</span> 777 .bashrc</span><br><span class="line">  </span><br><span class="line">  符号改变权限(u: <span class="built_in">users</span>, g: group, o: others, a: all):</span><br><span class="line">    +：加入, -：除去, =：设定</span><br><span class="line">    eg:</span><br><span class="line">      [-rwxr-xr--]</span><br><span class="line">        <span class="built_in">chmod</span> u=rwx,g=rx,o=r example.txt </span><br><span class="line">      给每个人均可写入的权限</span><br><span class="line">        <span class="built_in">chmod</span> a+w example.txt</span><br><span class="line">      去掉每个人可执行的权限</span><br><span class="line">      <span class="built_in">chmod</span> a-x example.txt</span><br></pre></td></tr></table></figure></li></ul><h4 id="Linux文件种类与扩展名"><a href="#Linux文件种类与扩展名" class="headerlink" title="Linux文件种类与扩展名"></a>Linux文件种类与扩展名</h4><ul><li><p>文件种类</p><ul><li><p>正规文件(regular file )</p><ol><li>纯文本(ASCII)</li><li>二进制文件(binary)</li><li>数据格式文件(data)</li></ol></li><li><p>目录(directory)</p></li><li><p>连接档(link)</p></li><li><p>设备与装置文件(device)</p><ol><li>区块设备档，例如硬盘与软盘等</li><li>字符设备文件，例如键盘，鼠标</li></ol></li><li><p>资料接口文件(sockets)</p></li><li><p>数据输送文件(FIFO, pipe)</p></li></ul></li><li><p>文件扩展名</p><p>Linux的文件没有所谓的扩展名，一个Linux能不能被执行，与其权限邮件，但是我们仍然希望可以接口扩展名来了解该文件是什么东西，常用的扩展名：</p><ul><li>*.sh: 脚本或批处理文件 (scripts)</li><li>*Z, *.tar, *.tar.gz, *.zip, *.tgz： 经过打包的压缩文件。</li><li>*.html, *.php：网页相关文件</li></ul></li><li><p>Linux 文件长度限制</p><p>单一文件或目录的最大容许文件名为 255bytes</p></li><li><p>Linux 文件名的限制</p><p>避免一些特殊字符: * ? &gt; &lt; ; &amp; ! [ ] | \ ‘ “ ` ( ) { }-+</p></li></ul><h2 id="Linux目录配置"><a href="#Linux目录配置" class="headerlink" title="Linux目录配置"></a>Linux目录配置</h2><h4 id="Linux-目录配置的依据–FHS"><a href="#Linux-目录配置的依据–FHS" class="headerlink" title="Linux 目录配置的依据–FHS"></a>Linux 目录配置的依据–FHS</h4><p>  Filesystem Hierarchy Standard (FHS)标准,规范每个特定的目录下应该要放置什么样子的数据</p><p>而已,将目录定义成为四种交互作用的形态：</p><table>    <tr>        <td></td>        <td>可分享的(shareable)</td>        <td>不可分享的(unshareable)</td>    </tr>    <tr>        <td rowspan="2">不变的(static)</td>        <td>/usr (软件放置处)</td>          <td>/etc (配置文件)</td>    </tr>    <tr>        <td>/opt (第三方协力软件)</td>          <td>/boot (开机与核心档)</td>    </tr>    <tr>        <td rowspan="2">可变动的(variable)</td>        <td>/var/mail (使用者邮件信箱)</td>        <td>/var/run (程序相关)</td>    </tr>    <tr>        <td>/var/spool/news (新闻组)</td>        <td>/var/lock (程序相关)</td>    </tr></table><p> 什么是四个类型：</p><ul><li>可分享的：可以分享给其他系统挂载使用的目录</li><li>不可分享的：自己机器上面运作的装置文件或者是与程序有关的 socket 文件等</li><li>不变的：有些数据是不会经常变动的，跟随着 distribution 而不变动</li><li>可变动的：经常改变的数据</li></ul><p>FHS 针对目录树架构仅定义出三层目录：</p><ul><li>/ (root, 根目录)：与开机系统有关；</li><li>/usr (unix software resource)：与软件安装/执行有关；</li><li>/var (variable)：与系统运作过程有关。</li></ul><h4 id="根目录-的意义与内容"><a href="#根目录-的意义与内容" class="headerlink" title="根目录(/)的意义与内容"></a>根目录(/)的意义与内容</h4><p>  根目录与开机/还原/系统修复等动作有关,根目录(/)所在分区槽应该越小越好， 且应用程序所安装的软件最好不要与根放在同一个分区槽内，保持根目录越小越好。 如此不但效能较佳，根目录所在的文件系统也较不容易发生问题。</p><table>    <tr>        <td>目录</td>        <td align="center">应该放置的文件内容</td>    </tr>    <tr>        <td colspan="2" align="center">第一部份：FHS 要求必须要存在的目录</td>    </tr>    <tr>        <td>/bin</td>          <td>放置执行文件的目录，主要有：cat, chmod, chown, date, mv, mkdir, cp, bash等等</td>    </tr>    <tr>        <td>/boot</td>          <td>放置开机会使用到的文件，包括Linux核心文件以及开机选单与开机所需配置文件等等. Linux kernel常用的档名为：vmlinuz，如果是 grub2 这个开机管理程序, 则还会存在/boot/grub2/这个目录</td>    </tr>      <tr>        <td>/dev</td>          <td>任何装置与接口设备都是以文件的型态存在于这个目录当中的，比要重要的文件有/dev/null, /dev/zero, /dev/tty, /dev/loop*, /dev/sd*等等</td>    </tr>      <tr>        <td>/etc</td>          <td>放置系统主要的配置文件，例如人员的账号密码文件、 各种服务的启始档等等。一般来说，这个目录下的各文件属性是可以让一般使用者查阅的，但是只有root有权力修改。FHS建议不要放置可执行文件(binary)在这个目录中。比较重要的文件有：/etc/modprobe.d/, /etc/passwd, /etc/fstab, /etc/issue等等。另外FHS还规范几个重要的目录最好要存在 /etc/ 目录下:<br>          &nbsp;&nbsp;&nbsp;&nbsp;- /etc/opt(必要)：这个目录在放置第三方协力软件 /opt 的相关配置文件<br>          &nbsp;&nbsp;&nbsp;&nbsp;- /etc/X11/(建议)：与X Window有关的各种配置文件都在这里，尤其是 xorg.conf 这个X Server 的配置文件<br>          &nbsp;&nbsp;&nbsp;&nbsp;- /etc/sgml/(建议)：与 SGML 格式有关的各项配置文件<br>          &nbsp;&nbsp;&nbsp;&nbsp;- /etc/xml/(建议)：与 XML 格式有关的各项配置文件<br>      </td>    </tr>      <tr>        <td>/lib</td>          <td>放置的是在开机时会用到的函式库，以及在/bin 或/sbin 底下的指令会呼叫的函式库而已。另外 FSH 还要求底下的目录必须要存在:<br>          &nbsp;&nbsp;&nbsp;&nbsp;- /lib/modules/：这个目录主要放置可抽换式的核心相关模块(驱动程序)      </td>    </tr>      <tr>        <td>/media</td>          <td>放置的就是可移除的装置，包括软盘、光盘、DVD 等等装置都暂时挂载于此，常见的档名有：/media/floppy, /media/cdrom等等          </td>    </tr>      <tr>        <td>/mnt</td>          <td>放置的暂时挂载某些额外的装置</td>    </tr>      <tr>        <td>/run</td>          <td>放置系统开机后所产生的各项信息应</td>    </tr>      <tr>        <td>/sbin</td>          <td>开机过程中所需要的指令，里面包括了开机、修复、还原系统</td>    </tr>      <tr>        <td>/srv</td>          <td>网络服务启动之后，这些服务所需要取用的数据目录</td>    </tr>      <tr>        <td>/tmp</td>          <td>正在执行的程序暂时放置文件的地方</td>    </tr>      <tr>        <td>/usr</td>          <td>Unix操作系统软件资源所放置的目录,里面放置的数据属于可分享的与不可变动的</td>    </tr>      <tr>        <td>/var</td>          <td>放置变动性的数据</td>    </tr>      <tr>        <td colspan="2" align="center">第二部份：FHS 建议可以存在的目录</td>    </tr>      <tr>        <td>/home</td>          <td>用户家目录,家目录有两种代号<br>            &nbsp;&nbsp;&nbsp;&nbsp; ~：代表目前这个用户的家目录<br>              &nbsp;&nbsp;&nbsp;&nbsp; ~dmtsai ：则代表 dmtsai 的家目录！          </td>    </tr>      <tr>        <td>/lib<qual></td>          <td>存放与 /lib 不同的格式的二进制函式库，例如支持 64 位的 /lib64 函式库等</td>    </tr>      <tr>        <td>/root</td>          <td>系统管理员(root)的家目录</td>    </tr>      <tr>        <td colspan="2" align="center">第三部份：非常重要的目录</td>    </tr>      <tr>        <td>/lost+found</td>          <td>是使用标准的 ext2/ext3/ext4 文件系统格式才会产生的一个目录,目的在于当文件系统发生错误时，将一些遗失的片段放置到这个目录下。不过如果使用的是xfs文件系统的话，就不会存在</td>    </tr>      <tr>        <td>/proc</td>          <td>虚拟文件系统(virtual filesystem),放置的数据都是在内存当中, 例如系统核心、行程信息(process)、周边装置的状态及网络状态等等。因为这个目录下的数据都是在内存当中， 所以本身不占任何硬盘空间啊！比较重要的文件例如：/proc/cpuinfo, /proc/dma, /proc/interrupts, /proc/ioports, /proc/net/* 等等</td>    </tr>      <tr>        <td>/proc</td>          <td>虚拟的文件系统, 主要也是记录核心与系统硬件信息较相关的信息。 包括目前已加载的核心模块与核心侦测到的硬件装置信息等等。这个目录同样不占硬盘容量</td>    </tr></table><h4 id="usr的意义与内容"><a href="#usr的意义与内容" class="headerlink" title="/usr的意义与内容"></a>/usr的意义与内容</h4><p>/usr(Unix Software Resource) 里面放置的数据属于可分享的与不可变动的(shareable, static),/usr 的次目录建议有底下这些</p><table>    <tr>        <td>目录</td>        <td align="center">应该放置的文件内容</td>    </tr>    <tr>        <td colspan="2" align="center">第一部份：FHS 要求必须要存在的目录</td>    </tr>    <tr>        <td>/usr/bin/</td>          <td>一般用户能够使用的指令都放在这里，另外，FHS要求在此目录下不应该有子目录！</td>    </tr>    <tr>        <td>/usr/lib/</td>          <td>基本上，与 /lib 功能相同，所以 /lib 就是链接到此目录中的</td>    </tr>      <tr>        <td>/usr/local/</td>          <td>系统管理员在本机自行安装自己下载的软件</td>    </tr>      <tr>        <td>/usr/sbin/</td>          <td>非系统正常运作所需要的系统指令。最常见的就是某些网络服务器软件的服务指令(daemon)！不过基本功能与 /sbin 也差不多， 因此目前 /sbin 就是链接到此目录中的      </td>    </tr>      <tr>        <td>/usr/share/</td>          <td>主要放置只读架构的数据文件，包括共享文件。在这个目录下放置的数据几乎是不分硬件架构均可读取的数据，在此目录下常见的还有这些次目录：<br>          &nbsp;&nbsp;&nbsp;&nbsp;- /usr/share/man：联机帮助文件<br>          &nbsp;&nbsp;&nbsp;&nbsp;- /usr/share/doc：软件杂项的文件说明<br>          &nbsp;&nbsp;&nbsp;&nbsp;- /usr/share/zoneinfo：与时区有关的时区文件      </td>    </tr>      <tr>        <td colspan="2" align="center">第二部份：FHS 建议可以存在的目录</td>    </tr>      <tr>        <td>/usr/games/</td>          <td>与游戏比较相关的数据放置处</td>    </tr>      <tr>        <td>/usr/include/</td>          <td>c/c++等程序语言的档头(header)与包含档(include)放置处</td>    </tr>      <tr>        <td>/usr/libexec/</td>          <td>不被一般使用者惯用的执行档或脚本(script)等等，都会放置在此目录中。例如大部分的 X 窗口底下的操作指令                </td>    </tr>      <tr>        <td>/usr/lib<qual>/</td>          <td>与 /lib<qual>/功能相同，因此目前 /lib<qual> 就是链接到此目录中</td>    </tr>      <tr>        <td>/usr/src/</td>          <td>一般原始码建议放置到这里，src 有 source 的意思。至于核心原始码则建议放置到/usr/src/linux/目录下                        </td>    </tr></table><h4 id="var-的意义与内容"><a href="#var-的意义与内容" class="headerlink" title="/var 的意义与内容"></a>/var 的意义与内容</h4><p>是在系统运作后才会渐渐占用硬盘容量的目录。 因为/var 目录主要针对常态性变动的文件，包括快取(cache)、登录档(log file)以及某些软件运作所产生的文件， 包括程序文件(lock file, run file)，或者例如 MySQL 数据库的文件等等。常见的次目录有:</p><table>    <tr>        <td>目录</td>        <td align="center">应该放置的文件内容</td>    </tr>    <tr>        <td colspan="2" align="center">第一部份：FHS 要求必须要存在的目录</td>    </tr>    <tr>        <td>/var/cache/</td>          <td>应用程序本身运作过程中会产生的一些暂存档</td>    </tr>    <tr>        <td>/var/lib/</td>          <td>程序本身执行的过程中，需要使用到的数据文件放置的目录</td>    </tr>      <tr>        <td>/var/lock/</td>          <td>某些程序和文件资源锁</td>    </tr>      <tr>        <td>/var/log/</td>          <td>登录文件放置的目录！里面比较重要的文件如/var/log/messages, /var/log/wtmp(记录登入者的信息)等</td>    </tr>      <tr>        <td>/var/mail/</td>          <td>放置个人电子邮件信箱的目录，这个目录也被放置到/var/spool/mail/目录中！通常这两个目录是互为链接文件                        </td>    </tr>      <tr>        <td>/var/run/</td>          <td>某些程序或者是服务启动后，会将他们的 PID 放置在这个目录下，与 /run 相同，这个目录链接到 /run</td>    </tr>      <tr>        <td>/var/spool/</td>          <td>放置一些队列数据，所谓的『队列』就是排队等待其他程序使用的数据，这些数据被使用后通常都会被删除</td>    </tr></table><h4 id="绝对路径与相对路径"><a href="#绝对路径与相对路径" class="headerlink" title="绝对路径与相对路径"></a>绝对路径与相对路径</h4><p>因为根据档名写法的不同，也可将所谓的路径(path)定义为绝对路径(absolute)与相对路径(relative)。 这两种文件名/路径的写法依据是这样的：</p><ul><li>绝对路径：由根目录(/)开始写起的文件名或目录名称， 例如 /home/dmtsai/.bashrc；</li><li>相对路径：相对于目前路径的文件名写法。 例如 ./home/dmtsai 或 ../../home/dmtsai/ 等等。反正开头不是 / 就属于相对路径的写法</li></ul><p>特别注意这两个特殊的目录：</p><ul><li>. ：代表当前的目录，也可以使用 ./ 来表示</li><li>.. ：代表上一层目录，也可以 ../ 来代表</li></ul><h1 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h1><hr><p>该笔记是摘抄自《鸟哥的Linux私房菜》，仅供自己学习使用，如有侵权请联系删除[<a href="mailto:&#49;&#x37;&#x35;&#x38;&#53;&#x37;&#x35;&#x39;&#x36;&#x39;&#x40;&#x71;&#x71;&#46;&#x63;&#111;&#x6d;">&#49;&#x37;&#x35;&#x38;&#53;&#x37;&#x35;&#x39;&#x36;&#x39;&#x40;&#x71;&#x71;&#46;&#x63;&#111;&#x6d;</a>]。原内容来自<a href="http://linux.vbird.org/linux_basic/0105computers.php#chipset">鸟哥的Linux私房菜</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
          <category> linux </category>
          
          <category> 鸟哥的Linux私房菜 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 鸟哥的Linux私房菜 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[鸟哥的Linux私房菜笔记] 第二章-主机规划与磁盘分区</title>
      <link href="/21dbf593282a/02_%E4%B8%BB%E6%9C%BA%E8%A7%84%E5%88%92%E4%B8%8E%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/"/>
      <url>/21dbf593282a/02_%E4%B8%BB%E6%9C%BA%E8%A7%84%E5%88%92%E4%B8%8E%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="各硬件装置在Linux中的文件名"><a href="#各硬件装置在Linux中的文件名" class="headerlink" title="各硬件装置在Linux中的文件名"></a>各硬件装置在Linux中的文件名</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. SCSI/SATA/USB硬盘</span><br><span class="line">   /dev/sd[a-p]</span><br><span class="line"></span><br><span class="line">2. USB快闪碟</span><br><span class="line">   /dev/sd[a-p](与SATA相同)</span><br><span class="line"></span><br><span class="line">3. VirtI/O界面</span><br><span class="line">   /dev/vd[a-p](用与虚拟机内)</span><br><span class="line"></span><br><span class="line">4. 软盘驱动器</span><br><span class="line">   /dev/fd[0-7]</span><br><span class="line"></span><br><span class="line">5. 打印机</span><br><span class="line">   /dev/lp[0-2](25-针打印机)</span><br><span class="line">   /dev/usb/lp[0-15](USB界面)</span><br><span class="line"></span><br><span class="line">6. 鼠标</span><br><span class="line">   /dev/input/mouse[0-15](通用)</span><br><span class="line">   /dev/psaux(PS/2界面)</span><br><span class="line">   /dev/mouse(当前鼠标)</span><br><span class="line"></span><br><span class="line">7. CDROM/DVDROM</span><br><span class="line">   /dev/scd[0-1](通用)</span><br><span class="line">   /dev/sr[0-1](通用,CentOS较常见)</span><br><span class="line">   /dev/cdrom(当前CDROM)</span><br><span class="line"></span><br><span class="line">8. 硬盘机</span><br><span class="line">   /dev/ht0(IDE界面)</span><br><span class="line">   /dev/st0(SATA/SCSI界面)</span><br><span class="line">   /dev/tape(当前磁带)</span><br><span class="line"></span><br><span class="line">9. IDE磁盘机</span><br><span class="line">   /dev/hd[a-d](旧时系统才有)</span><br></pre></td></tr></table></figure><h2 id="MSDOS-MBR-与GPT磁盘分区表-partition-table"><a href="#MSDOS-MBR-与GPT磁盘分区表-partition-table" class="headerlink" title="MSDOS(MBR)与GPT磁盘分区表(partition table)"></a>MSDOS(MBR)与GPT磁盘分区表(partition table)</h2><h4 id="为什么要分区？"><a href="#为什么要分区？" class="headerlink" title="为什么要分区？"></a>为什么要分区？</h4><ul><li><p>数据安全性</p><p>因为每个分区槽的数据是分开的，所以当你需要将某个分区槽的数据重整时，不会影响其他分区槽。</p></li><li><p>系统的效能考虑</p><p>由于分区槽将数据集中在某个磁柱的区段。例如第一个分区槽位于磁柱1到100号，这样当有数据要读取自该分区槽时，磁盘只会搜寻前面1到100的磁柱范围，由于数据集中了，将有助于数据的读取速度和效能。</p></li></ul><h4 id="MSDOS-MBR-主要启动记录区"><a href="#MSDOS-MBR-主要启动记录区" class="headerlink" title="MSDOS(MBR)主要启动记录区"></a>MSDOS(MBR)主要启动记录区</h4><p>早期的Linux系统为了兼容与Windows的磁盘，因此使用的是支持Windos的MBR(Master Boot Record，主要开机记录区)的方式来处理开机管理程序与分区表！而开机管理程序记录区与分区表则通通放在磁盘的第一个扇区，这个扇区通常是512btyes的大小(旧的磁盘扇区都是512bytes)。所以所第一个扇区512bytes会有这两个数据：</p><ul><li><strong>主要启动记录区(Master Boot Record, MBR)</strong>: 可以安装开机管理程序的地方，有446bytes</li><li><strong>分区表(partition table)</strong>: 记录整个磁盘分区的状态，有64bytes</li></ul><p>由于分区表所在的区块仅有64bytes容量，因此最多仅能有四组记录区，每组记录区记录了该区段的起始与结束的磁柱号码。可以得出以下几点重要信息：</p><ul><li>所谓的分区只是针对那个64bytes的分布表进行设定而已</li><li>硬盘默认的分区表仅能写入四组分区信息</li><li>四组分区信息我们称为主要(Primary)或延伸(Extended)分区槽</li><li>分区槽的最小单位通常为磁柱(cylinder)</li><li>当系统要写入磁盘时，一定会参考磁盘分区表，才能针对某个分区槽进行数据的处理</li></ul><h4 id="MBR主要分区、延伸分区与逻辑分区的特性"><a href="#MBR主要分区、延伸分区与逻辑分区的特性" class="headerlink" title="MBR主要分区、延伸分区与逻辑分区的特性"></a>MBR主要分区、延伸分区与逻辑分区的特性</h4><ul><li>主要分区与延伸分区最多可以有四笔(硬盘的限制)</li><li>延伸分区最多只能有一个(操作系统的限制)</li><li>逻辑分区是由延伸分区持续切割出来的分区槽</li><li>作为数据存取的分区槽为主要分区与逻辑分区，能够被格式化。延伸分区无法格式化。</li><li>逻辑分区的数量依操作系统而不同，在Linux系统中SATA硬盘已经可以突破63个以上的分区限制</li></ul><h4 id="MBR分区表的限制"><a href="#MBR分区表的限制" class="headerlink" title="MBR分区表的限制"></a>MBR分区表的限制</h4><ul><li>操作系统无法抓取到2.2T以上的磁盘容量</li><li>MBR仅有一个区块，若被破坏后，经常无法或很难救援。</li><li>MBR内的存放开机管理程序区块仅446bytes，无法容纳较多的程序代码。</li></ul><h4 id="GUID-partition-table-GPT磁盘分布表"><a href="#GUID-partition-table-GPT磁盘分布表" class="headerlink" title="GUID(partition table) GPT磁盘分布表"></a>GUID(partition table) GPT磁盘分布表</h4><p>过去一个扇区大小就是512bytes，现在已经有4K的扇区设计出现。为了兼容于所有的磁盘，因此在扇区的定义上面，大多会使用所谓的逻辑区块地址(Logical Block Address, LBA)来处理。GPT将磁盘所有区块以LBA(预设为512bytes)来规划，而第一个LBA称为LBA0(从0开始编号)。</p><p>与MBR仅使用第一个512bytes区块来记录不同，GPT使用了34个LBA区块来记录分区信息。GPT除了前面34个LBA之外，整个磁盘的最后33个LBA也拿来作为另一个备份。GPT的详细结构如下：</p><ul><li><p><strong>LBA0(MBR相容区块)</strong></p><p>与MBR模式相似的，这个兼容区块也分为两个部分，一个就是和之前446bytes相似的区块，储存了第一阶段的开机管理程序。而在原本的分区表记录区内，这个兼容模式仅放入了一个特殊标志的分区，用来标识此磁盘为GPT格式之意。而不懂GPT分区表的磁盘管理程序，就不会认识这个磁盘，除非用户有特别要求要处理这个磁盘，否则该管理软件不能修改此分区信息，进一步保护了该磁盘。</p></li><li><p><strong>LBA1(GPT表头记录)</strong></p><p>这个部分计了分区表本身的位置与大小，同时记录了备份用的GPT分区(最后34个LBA区块)放置的位置，同时放置了分区表的检验机制码(CRC32)。操作系统可以根据这个检验码来判断GPT是否正确。若有错误，还可以通过这个记录区来取得备份的GPT(磁盘最后的那个备份区块)来恢复GPT的正常运作。</p></li><li><p><strong>LBA2-33(实际记录分区信息处)</strong></p><p>从LBA2区块开始，每个LBA都可以记录4笔分区记录，所以在默认的情况下，总共可以有[4 * 32 = 128]笔分区记录。因为每个LBA有512bytes，因此每笔记录用到128bytes的空间，除了每笔记录所需要的标识符与相关的记录之外，GPT在每笔记录中分别提供了64bits来记载开始/结束的扇区号码。因此，GPT分布表对于单一分区槽来说，他的最大容量限制就会在[2^64 * 512bytes = 263 * 1Kbytes = 233*TB = 8 ZB]</p></li></ul><p>现在GPT分区预设可以提供多达128笔记录，而在Linux本身的核心装置记录中，针对单一磁盘来说，虽然过去最多只能道道15个分区槽，不过由于Linux kernel透过udev等方式的处理，现在Linux也已经没有这个限制了。此在，GPT分区已经没有所谓的主分区、延伸分区、逻辑分区的概念，既然每笔记录都可以独立存在，当然每个都可以视为是主分区，每个分区都可以拿来格式化使用。</p><p>并不是所有的操作系统都额可以读取到GPT的磁盘格式，同时，也不是所有的硬件都可以支持GPT格式。是否能够读写GPT格式与开机的检测程序有关。</p><h2 id="开机流程中的BIOS与UEFI开机检测程序"><a href="#开机流程中的BIOS与UEFI开机检测程序" class="headerlink" title="开机流程中的BIOS与UEFI开机检测程序"></a>开机流程中的BIOS与UEFI开机检测程序</h2><h4 id="开机到操作系统的流程"><a href="#开机到操作系统的流程" class="headerlink" title="开机到操作系统的流程"></a>开机到操作系统的流程</h4><ol><li><strong>BIOS</strong>：开机主动执行的固件，会认识第一个可开机的装置</li><li><strong>MBR</strong>：第一个开开机装置的第一个扇区内的主要启动记录区块，内含开机管理程序</li><li><strong>开机管理程序(boot loader)</strong>: 一支可读取核心文件来执行的软件</li><li><strong>核心文件</strong>：开始操作系统的功能…</li></ol><p>需要注意的第二点，如果你的分布表为GPT格式，那么BIOS也能够从LBA0的MBR兼容区块读取第一阶段的开机管理程序代码，如果你的开机管理程序不认识GPT，开机就会失败。其中开机管理程序除了可以安装在MBR之外，还可以安装在每个分区槽的启动扇区(boot sector)。</p><h4 id="boot-loader的主要任务"><a href="#boot-loader的主要任务" class="headerlink" title="boot loader的主要任务"></a>boot loader的主要任务</h4><ul><li><strong>提供选单</strong>: 用户可以选择不同的开机项目，这也是多重引导的重要功能</li><li><strong>载入核心文件</strong>: 直接指向可开机的程序区段来开始操作系统</li><li><strong>转交其他loader</strong>: 将开机管理功能转交给其他loader负责</li></ul><h4 id="传统BIOS与UEFI的差异"><a href="#传统BIOS与UEFI的差异" class="headerlink" title="传统BIOS与UEFI的差异"></a>传统BIOS与UEFI的差异</h4><table><thead><tr><th></th><th>传统BIOS</th><th>UEFI</th></tr></thead><tbody><tr><td>使用程序语言</td><td>汇编语言</td><td>C语言</td></tr><tr><td>硬件资源控制</td><td>使用中断(IRQ)管理<br />不可变的内存存取<br />不可变的输入/输出存取</td><td>使用驱动程序与协议</td></tr><tr><td>处理器运作环境<br />扩充方式</td><td>16位<br />通过IRQ连结</td><td>CPU保护模式<br />直接加载驱动程序</td></tr><tr><td>第三方厂商支持</td><td>较差</td><td>较佳且可支持多平台</td></tr><tr><td>图形化能力</td><td>较差</td><td>较佳</td></tr><tr><td>内建简化操作系统前环境</td><td>不支持</td><td>支持</td></tr></tbody></table><h4 id="常见的Linux服务功能"><a href="#常见的Linux服务功能" class="headerlink" title="常见的Linux服务功能"></a>常见的Linux服务功能</h4><ul><li><strong>NAT</strong>: 达成IP分享器的功能</li><li><strong>SAMBA</strong>：加入网上邻居功能</li><li><strong>Mail</strong>： 邮件服务器</li><li><strong>Web</strong>：WWW服务器</li><li><strong>DHCP</strong>：提供客户端自动获取IP的功能</li><li><strong>FTP</strong>：进行网络数据的传输</li></ul><h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 配置计算机硬件设备时，需要考虑的有[游戏机/工作机]、[效能/价格比]、[效能/消耗瓦数]、[支持度]等。</span><br><span class="line"></span><br><span class="line">2. 旧的硬件可能由于保存的问题或则是电子零件老化的问题，导致计算机系统非常容易在运作过程中出现不明的当机情况。</span><br><span class="line"></span><br><span class="line">3. 在Linux系统中，每个装置都被当成一个文件来对待，每个装置都会有装置文件名。</span><br><span class="line"></span><br><span class="line">4. 硬盘装置文件名通常分为两种，实际SATA/USB装置名为/dev/sd[a-p],而虚拟机的装置可能未/dev/vd[a-p]。</span><br><span class="line"></span><br><span class="line">5. 硬盘的第一个扇区主要记录了两个重要的信息，分别是：</span><br><span class="line">(1)主要启动记录区(Master Boot Record, MBR): 可以安装开机管理程序的地方，有446btyes 分区表(partition table)</span><br><span class="line">(2)记录整个硬盘分区的状态，有64bytes。</span><br><span class="line"></span><br><span class="line">6. 硬盘的MBR分区方式中，主要与延伸分区最多可以有四个，逻辑分区的装置文件名号码，一定由5号开始。</span><br><span class="line"></span><br><span class="line">7. 如果硬盘大于2TB以上时，系统会自动使用GPT分区方式来处理硬盘分区。</span><br><span class="line"></span><br><span class="line">8. GPT分区已经没有延伸与逻辑分区槽的概念，可以想象成所有的分区都是主分区。</span><br><span class="line"></span><br><span class="line">9. 某些操作系统要使用GPT分区时，必须要搭配UEFI的新型BIOS格式才可以安装使用。</span><br><span class="line"></span><br><span class="line">10. 开始的流程：BIOS -&gt; MBR -&gt; boot loader -&gt; 核心文件。</span><br><span class="line"></span><br><span class="line">11. boot loader的功能主要有：提供选单、加载核心、转交控制权给其他loader。</span><br><span class="line"></span><br><span class="line">12. boot loader可以安装的地点有两个，分别是MBR与boot loader。</span><br><span class="line"></span><br><span class="line">13. Linux操作系统的文件使用目录树系统，与磁盘的对应需要有[挂载]的动作才行。</span><br><span class="line"></span><br><span class="line">14. 新手的简单分区，建议只要有/及swap两个分区槽即可。</span><br></pre></td></tr></table></figure><h2 id="简答"><a href="#简答" class="headerlink" title="简答"></a>简答</h2><ol><li><p>请分析你的家庭计算机，以你的硬件配置来计算可能才生的耗电量，最终再以计算出的总瓦数乘上你可能开机的时间，以推算出一年你可能会花费多少钱在你的这部主机上面？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">硬件里面包括CPU、硬盘、主板、内存、显示适配器、屏幕等等都会消耗电力，同时电源供应器也会消耗一部分的电力，若有实际测量工具时，请使用测量结果来计算。若无测量工具，请上网找出每个配件的最大理论消耗功率来计算。</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>一部计算机主机是否只要CPU够快，整体速度就会提高？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不见得！一部计算机系统的与整体计算机系统的运作有关，每个组件皆会影响计算机的速度！这包括了内存、CPU、AGP与显示适配器速度，硬盘的速度以及其他相关的输入输出接口等等！所以，弱国您的系统是升级的，那么还得必须要注意各个旧组件是否可以保留，或者旧的可以用的组件必须要舍弃！</span><br></pre></td></tr></table></figure></li><li><p>Linux对于硬件的要求需要的考虑为何？是否一定要很高的配备才能安装Linux？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Linux对于硬件的要求是因服务种类、服务范围及主机的角色而定的。例如一部专门用来运算数值解析的Linux运算工作照，需要比较强大的CPU与足够RAM来进行工作，至于一般家庭用的仅用来做为ADSL宽带分享器的Linux主机，则只要P-III等级的计算机，设置P—II系列的等级，旧可以很顺利的运行Linux了。</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>一部好的主机在安装之前，最后先进行规划，哪些是必定需要注意的Linux主机规划事项？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Linux对于硬件的要求是因地制宜的，所以要进行Linux的安装之前，一定需要规划Linux主机的定位与角色！因此，Linux的主机是否开放网络服务？这部主机的未来规划中，是否需要进行大量的运算？这部主机是否需要提供很大的硬盘容量来服务客户端的使用？这部主机预计开放的网络服务内容？等等，都是需要经过考虑的，尤其未来的套件选择安装上面，更需要依据这些规划来设定。</span><br></pre></td></tr></table></figure></li></ol><h1 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h1><hr><p>该笔记是摘抄自《鸟哥的Linux私房菜》，仅供自己学习使用，如有侵权请联系删除[<a href="mailto:&#x31;&#x37;&#x35;&#56;&#x35;&#x37;&#53;&#x39;&#54;&#57;&#x40;&#x71;&#x71;&#x2e;&#99;&#111;&#109;">&#x31;&#x37;&#x35;&#56;&#x35;&#x37;&#53;&#x39;&#54;&#57;&#x40;&#x71;&#x71;&#x2e;&#99;&#111;&#109;</a>]。原内容来自<a href="http://linux.vbird.org/linux_basic/0105computers.php#chipset">鸟哥的Linux私房菜</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
          <category> linux </category>
          
          <category> 鸟哥的Linux私房菜 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 鸟哥的Linux私房菜 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[鸟哥的Linux私房菜笔记] 第一章-Linux是什么与如何学习</title>
      <link href="/ac33fd961cc8/01_Linux%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%8E%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/ac33fd961cc8/01_Linux%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%8E%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="芝士就是力量"><a href="#芝士就是力量" class="headerlink" title="芝士就是力量"></a>芝士就是力量</h2><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 操作系统(Operation System)主要在管理与驱动硬件，因此必须要能够管理内存、管理装置、负责行程管理以及系统呼叫等等。因此，只要能够让硬件准备妥当的情况，就是一个简单的操作系统了。</span><br><span class="line"></span><br><span class="line">2. Unix的前身是有贝儿实验室(Bell lab)的Ken Thompson利用汇编语言写成的，后来在1971-1973年间由Dennis Ritchie以C程序语言进行改写，才称为Unix。</span><br><span class="line"></span><br><span class="line">3. 1977年由Bill Joy释出BSD(Berkeley Software Distribution), 这些称为Unix-like的操作系统。</span><br><span class="line"></span><br><span class="line">4. 1984年由Andrew Tanenbaum开始制作Minix操作系统，该系统可以提供原始码以及软件。</span><br><span class="line"></span><br><span class="line">5. 1984年由Richard Stallman提倡GNU计划，倡导自由软件(Free software)，强调其软件可以「自由的取得、复制、修改与再发行」，并规范出GPL授权模式，任何GPL(General Public License)软件均不可单纯仅贩卖其软件，也不可修改软件授权。</span><br><span class="line"></span><br><span class="line">6. 1991年由芬兰人Linus Torvalds开发出Linux操作系统。简而言之，Linux成功的地方主要在于：Minix(Unix)，GNU, Internet, POSIX及虚拟团队的产生。</span><br><span class="line"></span><br><span class="line">7. 复合Open source理念的授权相当多，比较知名的如：Apache/BSD/GPL/MIT等。</span><br><span class="line"></span><br><span class="line">8. Linux本身就是个最简单的操作系统，其开发网站建立在http://www.kernel.org，我们亦称Linux操作系统最底层的数据为「核心(Kernel)」。</span><br><span class="line"></span><br><span class="line">9. 从Linux kernel 3.0开始，已经舍弃奇数、偶数的核心版本规划，新的规划使用主线版本(MainLine)为依据，并提供长期支持版本(longterm)来加强某些功能的持续维护。</span><br><span class="line"></span><br><span class="line">10. Linux distributions的组成含有：「Linux Kernel + Free Software + Documentations(Tools) + 可完全安装的程序」所制成的一套完整的系统。</span><br><span class="line"></span><br><span class="line">11. 常见的Linux distributions分类有「商业、社群」分类法，或「RPM、DPKG」分类法.</span><br><span class="line"></span><br><span class="line">12. 学习Linux最好从头由基础开始学习，找到一本适合自己的书籍，加强实做才能学会。</span><br></pre></td></tr></table></figure><h2 id="Linux的应用"><a href="#Linux的应用" class="headerlink" title="Linux的应用"></a>Linux的应用</h2><h4 id="企业环境"><a href="#企业环境" class="headerlink" title="企业环境"></a>企业环境</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 网络服务器</span><br><span class="line">2. 关键任务的应用(金融数据库、大型企业网络环境)</span><br><span class="line">3. 学术机构的高效能运算任务</span><br></pre></td></tr></table></figure><h4 id="个人环境"><a href="#个人环境" class="headerlink" title="个人环境"></a>个人环境</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 桌面计算机</span><br><span class="line">2. 手持系统(PDA、手机等)</span><br><span class="line">3. 嵌入式系统</span><br></pre></td></tr></table></figure><h4 id="云端应用"><a href="#云端应用" class="headerlink" title="云端应用"></a>云端应用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 云程序</span><br><span class="line">2. 端设备</span><br></pre></td></tr></table></figure><h2 id="Linux学习路线"><a href="#Linux学习路线" class="headerlink" title="Linux学习路线"></a>Linux学习路线</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 计算机概论与硬件相关知识</span><br><span class="line">2. Linux的安装与指令</span><br><span class="line">3. Linux操作系统的基础技能</span><br><span class="line">4. vi文本编辑器</span><br><span class="line">5. Shell与Shell Script的学习</span><br><span class="line">6. 会软件管理员</span><br><span class="line">7. 计算机网络基础</span><br></pre></td></tr></table></figure><h2 id="简答"><a href="#简答" class="headerlink" title="简答"></a>简答</h2><ol><li><p>你在你的主机上面安装了一张网络卡，但是开机之后，系统却无法使用，你确定网络卡是好的，那么可能的问题出在哪里？该如何解决？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">因为所有的硬件都没有问题，所以问题可能出在系统的核心(kernel)不支持这张网络卡。</span><br><span class="line">解决的方法：</span><br><span class="line">(1) 到网络卡的开发商网站；</span><br><span class="line">(2) 下载支持你主机操作系统的驱动程序;</span><br><span class="line">(3) 安装网卡驱动程序后，就可以使用了。</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>一个操作系统至少要能够完整的控制整个硬件，请问，操作系统应该要控制硬件的那些单元？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">根据硬件的运作，以及数据在主机上面的运算情况与写入/读取情况，我们知道至少要能够控制：</span><br><span class="line">(1) input/output control;</span><br><span class="line">(2) device control;</span><br><span class="line">(3) process management;</span><br><span class="line">(4) file management等等！</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>我在Windows上面玩的游戏，可不可以拿到Linux上去玩？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当然不行！因为游戏也是一个应用程序(application)，他必须要使用到核心所提供的工具来开发他的游戏，所以这个游戏是不可在不同的平台间运作的。除非这个游戏已经进行了移植。</span><br></pre></td></tr></table></figure></li><li><p>Linux本身仅是一个核心与相关的核心工具而已，不过，他已经可以驱动所有的硬件，所以，可以算是一个很简单的操作系统了，经过其他应用程序的开发之后，被整合称为Linux distribitions。请问众多的distributions之间，有何异动？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">相同：</span><br><span class="line">(1) 同样使用https://www.kernel.org所释出的核心；</span><br><span class="line">(2) 支持同样的标准，如FHS，LSB等；</span><br><span class="line">(3) 使用几乎相同的自由软件(例如GNU里面的gcc/glibc/apache/bind/sendmail...)；</span><br><span class="line">(4) 几乎相同的操作接口(例如均使用bash/KDE/GNOME等等)；</span><br><span class="line"></span><br><span class="line">不同：</span><br><span class="line">(1) 使用kernal与各软件的版本可能会不同；</span><br><span class="line">(2) 各开发商加入的应用工具不同;</span><br><span class="line">(3) 使用的套件管理模式不同(dpkg与RPM)</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>Unix是谁写出来的？GNU计划是谁发起的？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Unix是Ken Thompson写的，1973年再由Dennis Ritchie以C语言改写成功。至于GNU与FSF则是Richard Stailman发起的。</span><br></pre></td></tr></table></figure></li></ol><ol start="6"><li><p>GNU的全名为何？他主要由哪个基金会支持？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GNU是GNU is Not Unix的简写，是个无穷循环！另外，这个计划是由自由软件基金会(Free Software Fundation, FSF)所支持的！两者都是由Stialman先生所发起的！</span><br></pre></td></tr></table></figure></li></ol><ol start="7"><li><p>何谓多人(Multi-user) 多任务(Multi-task)？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Multi-user: 指的是Linux允许多人同时连上主机之外，每个用户皆有其个人的使用环境，并且可以同时使用系统的资源！</span><br><span class="line">Multi-task: 指的是多任务环境，在Linux系统下，CPU与其他例如网络资源可以同时进行多项任务，Linux最大的特色之一即在于其多任务时，资源分配较为平均！</span><br></pre></td></tr></table></figure></li></ol><ol start="8"><li><p>简单说明GNU General Public License(GPL)与Open Source的精神。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1) GPL的授权之软件，乃为自由软件(Free software)，任何人皆可拥有它；</span><br><span class="line">(2) 开发GPL的团体(或商业企业)可以经由该软件的服务来取得服务的费用；</span><br><span class="line">(3) 经过GPL授权的软件，其属于Open source的情况，所以应该公布其原始码；</span><br><span class="line">(4) 任何人皆可修改经由GPL授权过的软件，是符合自己的需求；</span><br><span class="line">(5) 经过修改后Open Source应该回馈给Linux社群。</span><br></pre></td></tr></table></figure></li></ol><ol start="9"><li><p>什么是POSIX？为何说Linux使用POSIX对于发展有很好的影响？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POSIX是一种标准规范，主要针对在Unix操作系统上面跑的程序来进行规范。若你的操作系统符合POSIX，则符合POSIX的程序就可以在你的操作系统上面运行。Linux由于支持POSIX，因此很多Unix上的程序可以直接在Linux上运行，因此程序的移植相当简易！也让大家容易转换平台，提升Linux的使用率。</span><br></pre></td></tr></table></figure></li></ol><ol start="10"><li><p>简单说明Linux成功因素？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1) 借由Minix操作系统开发的Unix Like，没有版权的纠纷；</span><br><span class="line">(2) 借助于CNU计划所提供的各项工具软件，gcc/bash等；</span><br><span class="line">(3) 借由Internet广为流传；</span><br><span class="line">(4) 借由支持POSIX标准，让核心能够适合所有软件的开发；</span><br><span class="line">(5) Linus Torvalds强调务实，虚拟团队的自然形成！</span><br></pre></td></tr></table></figure></li></ol><h1 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h1><hr><p>该笔记是摘抄自《鸟哥的Linux私房菜》，仅供自己学习使用，如有侵权请联系删除[<a href="mailto:&#x31;&#55;&#53;&#56;&#x35;&#55;&#x35;&#57;&#54;&#x39;&#64;&#113;&#x71;&#x2e;&#99;&#x6f;&#109;">&#x31;&#55;&#53;&#56;&#x35;&#55;&#x35;&#57;&#54;&#x39;&#64;&#113;&#x71;&#x2e;&#99;&#x6f;&#109;</a>]。原内容来自<a href="http://linux.vbird.org/linux_basic/0105computers.php#chipset">鸟哥的Linux私房菜</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
          <category> linux </category>
          
          <category> 鸟哥的Linux私房菜 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 鸟哥的Linux私房菜 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[鸟哥的Linux私房菜笔记] 第零章-计算器概论</title>
      <link href="/9b2ca865585c/00_%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E8%AE%BA/"/>
      <url>/9b2ca865585c/00_%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="芝士就是力量"><a href="#芝士就是力量" class="headerlink" title="芝士就是力量"></a>芝士就是力量</h2><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 计算器的定义: 接受用户的输入指令和数据，经由中央处理器的数学与逻辑单元运算处理后，以产生或存储成有用的信息。</span><br><span class="line"></span><br><span class="line">2. 计算机的五大单元: 接受用户的输入指令和数据，经由中央处理器的数学与逻辑单元运算处理后，以产生或存储成有用的信息。</span><br><span class="line"></span><br><span class="line">3. 数据会流进/流出内存是CPU所发布的控制命令，而CPU实际要处理的数据则完全来自于主存储器</span><br><span class="line"></span><br><span class="line">4. CPU依设计理念主要分为: 精简指令集(RISC)与复杂指令集(CISC)系统。</span><br><span class="line"></span><br><span class="line">6. CPU频率: 外频指的是CPU与外部组件进行数据传输时的速度，倍频则是CPU内部用来加速工作效能的一个倍数，两者相乘才是CPU的频率速度。</span><br><span class="line"></span><br><span class="line">7. 新的CPU设计中，已经将北桥的内存控制芯片整合到CPU内，而CPU与主存储器、显示适配器沟通的总线通常称为系统总线。南桥就是所谓的输入输出(I/O)总线，主要在联系硬盘、USB、网络卡等接口设备。</span><br><span class="line"></span><br><span class="line">8. CPU每次能够处理的数据量称为字组大小(word size)，字组大小依据CPU的设计而有32位与64位。我们现在所称的计算机是32或64位主要依据这个CPU解析的字组大小而来的！</span><br><span class="line"></span><br><span class="line">9. 个人计算机的主存储器主要组件为动态随机存取内存(Dynamic Random Access Memory, DRAM)，至于CPU内部的第二层快取则使用静态随机存取内存(Static Random Access Memory, SRAM).</span><br><span class="line"></span><br><span class="line">10. BIOS(Basic Input Output System)是一套程序，这套程序是写死在主板上面的一个内存芯片中，这个内存芯片在没有通电时也能够将数据记录下来，那就是只读存储器(Read Only Memory, ROM)。</span><br><span class="line"></span><br><span class="line">11. 目前主流的外接卡界面大多为PICe界面，且最新的为PCIe3.0，单信道速度高达1GBytes/s。</span><br><span class="line"></span><br><span class="line">12. 常见的显示适配器连接到屏幕的界面有HDMI/DVI/D-Sub/Display port等等。HDMI可同时传荣影像与声音。</span><br><span class="line"></span><br><span class="line">13. 传统硬盘的组成为：圆形磁盘盘、机械手臂、磁盘读取头与主轴马达所组成的，其中磁盘盘的组成为扇区、磁道与磁柱。</span><br><span class="line"></span><br><span class="line">14. 磁盘连接到主板的界面大多为SATA或SAS，目前桌机主流为SATA3.0，理论极速可达600Mbytes/s。</span><br><span class="line"></span><br><span class="line">15. 常见的文字编码为ASCII，繁体中文编码主要有Big5及UTF8两种，目前主流为UTF8。</span><br><span class="line"></span><br><span class="line">16. 计算机主要以二进制为单位，常用的磁盘容量单位为bytes，其单位换算为1Byte = 8bits。</span><br><span class="line"></span><br><span class="line">17. 最基本的操作系统仅在驱动与管理硬件，而要使用硬件时，就得需要透过应用软件或是壳程序(shell)的功能，来呼叫操作系统操作硬件工作。目前称为操作系统的，除了上述功能外，通常已经包含了日常工作所需要的应用软件在内。</span><br></pre></td></tr></table></figure><h1 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h1><hr><p>该笔记是摘抄自《鸟哥的Linux私房菜》，仅供自己学习使用，如有侵权请联系删除[<a href="mailto:&#49;&#55;&#x35;&#56;&#x35;&#x37;&#53;&#57;&#54;&#x39;&#x40;&#x71;&#113;&#x2e;&#x63;&#x6f;&#109;">&#49;&#55;&#x35;&#56;&#x35;&#x37;&#53;&#57;&#54;&#x39;&#x40;&#x71;&#113;&#x2e;&#x63;&#x6f;&#109;</a>]。原内容来自<a href="http://linux.vbird.org/linux_basic/0105computers.php#chipset">鸟哥的Linux私房菜</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
          <category> linux </category>
          
          <category> 鸟哥的Linux私房菜 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 鸟哥的Linux私房菜 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[计算机图形学_华中科技大学笔记] 02_01_浅析图形学</title>
      <link href="/64d618b12afc/02_01_%E6%B5%85%E6%9E%90%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
      <url>/64d618b12afc/02_01_%E6%B5%85%E6%9E%90%E5%9B%BE%E5%BD%A2%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机图形系统的功能"><a href="#计算机图形系统的功能" class="headerlink" title="计算机图形系统的功能"></a>计算机图形系统的功能</h1><ul><li>计算</li><li>存储</li><li>输入</li><li>输出</li><li>交互</li></ul><h1 id="计算机图形系统的组成"><a href="#计算机图形系统的组成" class="headerlink" title="计算机图形系统的组成"></a>计算机图形系统的组成</h1><h1 id="图形硬件"><a href="#图形硬件" class="headerlink" title="图形硬件"></a>图形硬件</h1><h1 id="图形软件"><a href="#图形软件" class="headerlink" title="图形软件"></a>图形软件</h1>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
          <category> computer graphics </category>
          
          <category> 计算机图形学_华中科技大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[JS基础] 异步队列</title>
      <link href="/9b66fb1881c4/async_queue/"/>
      <url>/9b66fb1881c4/async_queue/</url>
      
        <content type="html"><![CDATA[<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>当需要将方法以异步的方式进行执行，但同时又需要保证执行的顺序。例如：</p><ul><li>存粹的异步测试</li><li>弹出一系列提示消息(自动控制)</li><li>多个弹窗，一个弹窗关闭后，再弹出下一个弹窗(手动控制)<span id="more"></span></li></ul><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul><li>将需要执行的方法放在同一个队列当中</li><li>上一个方法执行时暂停队列</li><li>上一个方法执行完后，再自动/手动去调用下一个执行方法。</li></ul><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@classdesc</span> 异步队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AsyncQueue</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@prop</span> 方法队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="attr">_queue</span>: <span class="title class_">Function</span>[] = [];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@prop</span> 是否暂停</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="attr">_isPaused</span>: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@prop</span> 间隔时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="attr">_intervalTime</span>: <span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否自动开始</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="attr">_isAutoStart</span>: <span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否自动继续</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="attr">_isAutoResume</span>: <span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定时器id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="attr">_timer</span>: <span class="built_in">number</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> intervalTime 间隔时间(默认为1)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isAutoResume 是否自动继续(默认为true)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isAutoStart  是否自动开始(默认为true)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">constructor</span> (<span class="attr">intervalTime</span>: <span class="built_in">number</span> = <span class="number">1</span>, <span class="attr">isAutoResume</span>: <span class="built_in">boolean</span> = <span class="literal">true</span>, <span class="attr">isAutoStart</span>: <span class="built_in">boolean</span> = <span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_intervalTime</span> = intervalTime;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_isAutoResume</span> = isAutoResume;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_isAutoStart</span> = isAutoStart;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fn 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    add = <span class="function">(<span class="params">fn: <span class="built_in">Function</span></span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_queue</span>.<span class="title function_">push</span>(fn);</span><br><span class="line">        </span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_isAutoStart</span> &amp;&amp; <span class="variable language_">this</span>.<span class="title function_">run</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 运行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    run = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_isPaused</span> || !<span class="variable language_">this</span>.<span class="property">_queue</span>.<span class="property">length</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 暂停</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">stop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// FIFO</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_queue</span>.<span class="title function_">shift</span>()();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">_isAutoResume</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 继续</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">resume</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 继续</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    resume = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_timer</span> &amp;&amp; <span class="built_in">clearTimeout</span>(<span class="variable language_">this</span>.<span class="property">_timer</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_timer</span> = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">_isPaused</span> = <span class="literal">false</span>;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">run</span>();</span><br><span class="line">        &#125;, <span class="variable language_">this</span>.<span class="property">_intervalTime</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 暂停</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    stop = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_isPaused</span> = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>简单的测试使用</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncQueue = <span class="keyword">new</span> <span class="title function_">asyncQueue</span>(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">asyncQueue</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;test1&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">asyncQueue</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;test2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">asyncQueue</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;test3&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h1><hr><p>该文章是学习《JavaScript Ninja》的笔记，仅供自己学习使用，如有侵权请联系删除[<a href="mailto:&#x31;&#55;&#x35;&#x38;&#x35;&#55;&#x35;&#57;&#54;&#x39;&#x40;&#113;&#113;&#x2e;&#99;&#111;&#x6d;">&#x31;&#55;&#x35;&#x38;&#x35;&#55;&#x35;&#57;&#54;&#x39;&#x40;&#113;&#113;&#x2e;&#99;&#111;&#x6d;</a>]。</p><hr>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
          <category> javascript </category>
          
          <category> basics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Tools] nodejs导出excel表数据</title>
      <link href="/0e3a86c68e36/xlsx2json/"/>
      <url>/0e3a86c68e36/xlsx2json/</url>
      
        <content type="html"><![CDATA[<h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><ul><li>配置基本配置<ul><li>excel路径</li><li>导出文件路径</li><li>导出文件格式</li><li>公式导出</li></ul></li><li>读取excel表数据<span id="more"></span><ul><li>深层文件夹读取</li></ul></li><li>处理excel表数据<ul><li>处理一张excel包含多张sheet</li><li>定义导出数据格式</li></ul></li><li>写入数据到文件<ul><li>导出普通字段</li><li>导出公式ts文件</li></ul></li></ul><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h2><ul><li><p>安装node</p></li><li><p>安装npm包</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yarn：       [npm i yarn -g] 可以选择安装, 安装后可用&quot;yarn add&quot;, 不安装用&quot;npm i&quot;</span><br><span class="line">typescript： [yarn add typescript --dev] 支持typescript</span><br><span class="line">xlsx：       [yarn add xlsx --dev] 读取excel表数据</span><br><span class="line">jsonfile：   [yarn add jsonfile --dev] 读取json数据</span><br><span class="line">ts-node：    [yarn add ts-node --dev] 代码提示</span><br><span class="line">ts-node-dev：[yarn add ts-node-dev --dev]</span><br><span class="line">nodemon：    [yarn add nodemon --dev] 监视启动目录中的文件，如果有文件更改，自动重启node应用</span><br><span class="line">codenotices：[yarn add @types/node @types/jsonfile @types/xlsx] 代码提示</span><br></pre></td></tr></table></figure></li><li><p>初始化tsconfig</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">项目根目录下执行: tsc -init</span><br></pre></td></tr></table></figure></li><li><p>修改tsconfig配置(可参考官方文档<a href="https://www.tslang.cn/docs/handbook/compiler-options.html">https://www.tslang.cn/docs/handbook/compiler-options.html</a>)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;target&quot;: &quot;es5&quot;, // 指定ECMAScript目标版本</span><br><span class="line">&quot;module&quot;: &quot;commonjs&quot;, // 指定生成哪个模块系统代码</span><br><span class="line">&quot;sourceMap&quot;: true, // 生成相应的 .map文件</span><br><span class="line">&quot;outDir&quot;: &quot;./dist&quot;, // 重定向输出目录</span><br><span class="line">&quot;rootDir&quot;: &quot;./src&quot;, // 控制输出的目录结构</span><br><span class="line">&quot;strict&quot;: true, // 启用所有严格类型检查选项</span><br><span class="line">&quot;moduleResolution&quot;: &quot;node&quot;, // 决定如何处理模块</span><br><span class="line">&quot;esModuleInterop&quot;: true,    // 允许从没有设置默认导出的模块中默认导入</span><br><span class="line">&quot;forceConsistentCasingInFileNames&quot;: true, 禁止对同一个文件的不一致的引用</span><br></pre></td></tr></table></figure></li><li><p>设置脚本命令(执行：yarn | npm run 脚本命令)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;node dist/main.js&quot;, // 执行main.js</span><br><span class="line">    &quot;dev&quot;: &quot;nodemon src/main.ts&quot;, // 监听并执行main.ts</span><br><span class="line">    &quot;build&quot;: &quot;tsc -p .&quot;           // 构建ts为js</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li></ul><h2 id="项目实现源码"><a href="#项目实现源码" class="headerlink" title="项目实现源码"></a>项目实现源码</h2><p><a href="https://github.com/guitarhgr/xlsx_2_json">https://github.com/guitarhgr/xlsx_2_json</a></p><p>src/types.ts：定义类型文件</p><p>src/main.ts：主程序文件</p><h2 id="创建启动入口批处理程序"><a href="#创建启动入口批处理程序" class="headerlink" title="创建启动入口批处理程序"></a>创建启动入口批处理程序</h2><p>创建一个start.bat(右键创建一个文件将后缀名改为xxxx.bat)批处理程序：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">start cmd /k &quot;yarn start&quot;</span><br></pre></td></tr></table></figure><p>这样就不用每次启动cmd输入启动脚本导出，每次就直接执行这个批处理程序start.bat.</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>参考<a href="https://github.com/guitarhgr/xlsx_2_json/blob/master/README.md">https://github.com/guitarhgr/xlsx_2_json/blob/master/README.md</a> </p>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
          <category> nodejs </category>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typescript </tag>
            
            <tag> nodejS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[JS基础] 定时器管理器</title>
      <link href="/49e8c613abeb/timermgr/"/>
      <url>/49e8c613abeb/timermgr/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么需要一个定时器管理器？"><a href="#为什么需要一个定时器管理器？" class="headerlink" title="为什么需要一个定时器管理器？"></a>为什么需要一个定时器管理器？</h1><p>保留大量定时器的引用，会干扰浏览器的运行。增加浏览器的垃圾回收任务发生的可能性(垃圾回收就是浏览器遍历其分配过的内存，并试图删除没有任何应用的未使用对象的过程)。有些浏览器页面上的动画可能出现卡顿。</p><span id="more"></span><h1 id="使用定时器管理器的好处"><a href="#使用定时器管理器的好处" class="headerlink" title="使用定时器管理器的好处"></a>使用定时器管理器的好处</h1><ul><li>每个页面(整个项目)在同一时间只需要运行一个定时器</li><li>可以根据需要暂停/恢复定时器</li></ul><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>把要执行所有的方法都添加到一个列表里面，由一个定时器去驱动。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @classdesc 定时器管理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TimerMgr</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间间隔(毫秒)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="attr">_timeStep</span>: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否运行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="attr">_isRunning</span>: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否暂停</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="attr">_isPaused</span>: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定时器id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="attr">_timer</span>: <span class="built_in">number</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行方法列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="attr">_funcList</span>: <span class="title class_">Function</span>[] = [];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeStep 时间间隔(默认为0)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">constructor</span> (<span class="attr">timeStep</span>: <span class="built_in">number</span> = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_timeStep</span> = timeStep;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> 执行方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    add = <span class="function">(<span class="params">func: <span class="built_in">Function</span></span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_funcList</span>.<span class="title function_">push</span>(func);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_isRunning</span> || <span class="variable language_">this</span>.<span class="property">_isPaused</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">run</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    start = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_isPaused</span> = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 运行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    run = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_timer</span> &amp;&amp; <span class="built_in">clearTimeout</span>(<span class="variable language_">this</span>.<span class="property">_timer</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_timer</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_isPaused</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否存在执行的方法列表</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">_funcList</span>.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">_isRunning</span> = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_isRunning</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历方法列表执行添加的方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">_funcList</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="attr">func</span>:<span class="title class_">Function</span> = <span class="variable language_">this</span>.<span class="property">_funcList</span>[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果有返回值为false则删除</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">func</span>() === <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">_funcList</span>.<span class="title function_">splice</span>(i, <span class="number">1</span>);</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            func = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_timer</span> = <span class="built_in">setTimeout</span>(<span class="variable language_">this</span>.<span class="property">run</span>, <span class="variable language_">this</span>.<span class="property">_timeStep</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 暂停</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    stop = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_isPaused</span> = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    clear = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_timer</span> &amp;&amp; <span class="built_in">clearTimeout</span>(<span class="variable language_">this</span>.<span class="property">_timer</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_timer</span> = <span class="literal">null</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_funcList</span> = [];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> timerMgr = <span class="keyword">new</span> <span class="title class_">TimerMgr</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// console.log() 1-10</span></span><br><span class="line">timerMgr.<span class="title function_">add</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`count:: <span class="subst">$&#123;count&#125;</span>`</span>);</span><br><span class="line">    count++</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一直执行</span></span><br><span class="line">timerMgr.<span class="title function_">add</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;loop&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
          <category> javascript </category>
          
          <category> basics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[JS基础] 函数重载</title>
      <link href="/436b1afd8e8e/overload/"/>
      <url>/436b1afd8e8e/overload/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是函数的重载？"><a href="#什么是函数的重载？" class="headerlink" title="什么是函数的重载？"></a>什么是函数的重载？</h1><p>具有相同的名称，不同参数列表的函数</p><span id="more"></span><h1 id="重载函数的方法"><a href="#重载函数的方法" class="headerlink" title="重载函数的方法"></a>重载函数的方法</h1><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><ul><li><p>检查参数列表使用switch或者if-else来执行不同的行为，但这个方法，如果重载过多代码就会冗余笨拙(这里不做介绍)。</p></li><li><p>利用闭包和函数的length属性。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">闭包：MSDN的解释，函数与对其状态即词法环境（lexical environment）的引用共同构成闭包（closure）。也就是说，闭包可以让你从内部函数访问外部函数作用域。在JavaScript，函数在每次创建时生成闭包。</span><br><span class="line">函数的length属性：这个属性是函数声明时所需要传入的形参数量。而arguments.length是函数在调用时传入的参数数量。</span><br></pre></td></tr></table></figure></li></ul><h2 id="利用闭包和函数length进行函数重载"><a href="#利用闭包和函数length进行函数重载" class="headerlink" title="利用闭包和函数length进行函数重载"></a>利用闭包和函数length进行函数重载</h2><h3 id="方法实现"><a href="#方法实现" class="headerlink" title="方法实现"></a>方法实现</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加重载函数：该方法每一层都会检查参数个数是否匹配。如果不匹配就继续检查上一层创建的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj 绑定方法的对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name 方法名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fn 方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">addOverloadFn</span> = (<span class="params">obj: <span class="built_in">Object</span>, name: <span class="built_in">string</span>, fn: <span class="built_in">Function</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 保存一下之前的方法</span></span><br><span class="line">    <span class="keyword">const</span> oldFn = obj[name];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新匿名函数作为新方法</span></span><br><span class="line">    obj[name] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 判断该匿名函数的传入实际参数个数和声明的形参个数</span></span><br><span class="line">        <span class="keyword">if</span> (fn.<span class="property">length</span> == <span class="variable language_">arguments</span>.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> oldFn == <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> oldFn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法测试"><a href="#方法测试" class="headerlink" title="方法测试"></a>方法测试</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无参</span></span><br><span class="line"><span class="title function_">addOverloadFn</span>(gays, <span class="string">&#x27;find&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">vals</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个参数</span></span><br><span class="line"><span class="title function_">addOverloadFn</span>(gays, <span class="string">&#x27;find&#x27;</span>, <span class="keyword">function</span> (<span class="params">firstName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">vals</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">vals</span>[i].<span class="title function_">indexOf</span>(firstName) == <span class="number">0</span>) &#123;</span><br><span class="line">            result.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">vals</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个参数</span></span><br><span class="line"><span class="title function_">addOverloadFn</span>(gays, <span class="string">&#x27;find&#x27;</span>, <span class="keyword">function</span> (<span class="params">firstName: <span class="built_in">string</span>, lastName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">this</span>.<span class="property">vals</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">vals</span>[i] === <span class="string">`<span class="subst">$&#123;firstName&#125;</span> <span class="subst">$&#123;lastName&#125;</span>`</span>) &#123;</span><br><span class="line">            result.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">vals</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gays.<span class="title function_">find</span>()); <span class="comment">// [&quot;Li Hua&quot;, &quot;Han MeiMei&quot;, &quot;Li Lei&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gays.<span class="title function_">find</span>(<span class="string">&#x27;Li&#x27;</span>)); <span class="comment">// [&quot;Li Hua&quot;, &quot;Li Lei&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gays.<span class="title function_">find</span>(<span class="string">&#x27;Han&#x27;</span>)); <span class="comment">// [&quot;Han MeiMei&quot;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(gays.<span class="title function_">find</span>(<span class="string">&#x27;Li&#x27;</span>, <span class="string">&#x27;Hua&#x27;</span>)); <span class="comment">// [&quot;Li Hua&quot;]</span></span><br></pre></td></tr></table></figure><h1 id="重载已有函数"><a href="#重载已有函数" class="headerlink" title="重载已有函数"></a>重载已有函数</h1><p>​    函数包装是一种封装函数逻辑的技巧，用于在单个步骤内重载创建新函数或继承函数。最有价值的场景是，在重载一些已经存在的函数时，同时保持原始函数在被包装后依然能够有效使用。</p><p>​    例如Prototype’s的readAttribute()方法：</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 包装函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> obj 包装对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fnName 方法名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fn 方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">wrap</span> = (<span class="params">obj: <span class="built_in">Object</span>, fnName: <span class="built_in">string</span>, fn: <span class="built_in">Function</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">originFn</span>: <span class="title class_">Function</span> = obj[fnName];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj[fnName] = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fn.<span class="title function_">apply</span>(</span><br><span class="line">            <span class="variable language_">this</span>,</span><br><span class="line">            [originFn.<span class="title function_">bind</span>(<span class="variable language_">this</span>)].<span class="title function_">concat</span>(</span><br><span class="line">                <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">readAttribute</span>: <span class="function">(<span class="params">a: <span class="built_in">number</span>, b?: <span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;a&#125;</span>::<span class="subst">$&#123;b&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">wrap</span>(obj, <span class="string">&#x27;readAttribute&#x27;</span>, <span class="function">(<span class="params">originFn: <span class="built_in">Function</span>, a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> &#123;</span><br><span class="line">    !b ? <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`wrapped <span class="subst">$&#123;a&#125;</span>::<span class="subst">$&#123;b&#125;</span> `</span>) :</span><br><span class="line">         <span class="title function_">originFn</span>(a, b);</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">readAttribute</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>该函数实现了对一个已经存在函数的重写，取而代之的是一个新函数。但这个新函数仍然可以访问原有函数提供的方法。这意味着，一个函数可以很安全的被重载，并同时仍然保留原有的功能。</p><h1 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h1><hr><p>该文章是学习《JavaScript Ninja》的笔记，仅供自己学习使用，如有侵权请联系删除[<a href="mailto:&#49;&#x37;&#x35;&#56;&#53;&#x37;&#x35;&#57;&#x36;&#57;&#64;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#x6d;">&#49;&#x37;&#x35;&#56;&#53;&#x37;&#x35;&#57;&#x36;&#57;&#64;&#x71;&#x71;&#x2e;&#x63;&#x6f;&#x6d;</a>]。</p><hr>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
          <category> javascript </category>
          
          <category> basics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[计算机图形学_华中科技大学笔记] 01_初始图形学</title>
      <link href="/f9cf890403f4/01_%E5%88%9D%E5%A7%8B%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
      <url>/f9cf890403f4/01_%E5%88%9D%E5%A7%8B%E5%9B%BE%E5%BD%A2%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机图形学"><a href="#计算机图形学" class="headerlink" title="计算机图形学"></a>计算机图形学</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>研究怎样利用计算机来显示，生成和处理图形的原理，方法和技术的一门学科。</p><span id="more"></span><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><ul><li>输入：结构特征数据(eg.直线：输入就是直线方程)</li><li>输出：图像信号(eg.直线：显示设备上最佳逼近这条直线的点阵)</li></ul><h2 id="相关学科"><a href="#相关学科" class="headerlink" title="相关学科"></a>相关学科</h2><h3 id="计算机视觉"><a href="#计算机视觉" class="headerlink" title="计算机视觉"></a>计算机视觉</h3><ul><li>输入：图像信号</li><li>输出：结构特征数据</li><li>运用：例如人脸识别，车牌识别等 </li></ul><h3 id="数字图像处理"><a href="#数字图像处理" class="headerlink" title="数字图像处理"></a>数字图像处理</h3><ul><li>输入：图像信号</li><li>输出：图像信号</li><li>运用：PhotoShop等</li></ul><h3 id="相关学科图"><a href="#相关学科图" class="headerlink" title="相关学科图"></a>相关学科图</h3><p><img src="https://raw.githubusercontent.com/guitarhgr/imagecloud/master/images/Code/CG/CGC/01_01.png" alt="相关学科图"></p><h2 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h2><h3 id="第一阶段：建立学科地位"><a href="#第一阶段：建立学科地位" class="headerlink" title="第一阶段：建立学科地位"></a>第一阶段：建立学科地位</h3><ul><li>1950年，第一台图形显示器作为美国麻省理工学院（MIT）旋风I号（Whirlwind I）计算机的附件诞生了。这是一台类似于示波器的阴极射线管（Cathod Ray Tube，简称CRT）。它的出现架起了图形显示与计算机技术联系的桥梁。</li><li>20世纪50年代末期，MIT的林肯实验室在旋风I号（Whirlwind I）计算机上为北美防空司令部开发了半自动地面防空系统（Semi-Automatic Ground Environment 简称SAGE）。SAGE系统将雷达信号转换为显示器上的图形，操作者可以用“光笔”在屏幕上选取目标图形，这是最早的交互式图形系统。标志着“被动式图形学”开始迈向“交互式图形学”。</li><li>1962年，MIT林肯实验室的伊凡·萨瑟兰（Ivan  Edward  Sutherland）发表了一篇题为“Sketchpad：A Man-machine Graphical Communication System”（Sketchpad：一个人机交互通信的图形系统）的博士论文,在这篇论文首次提出“Computer Graphics”，奠定了计算机图形学的学科基础。</li></ul><h3 id="第二阶段：光栅图形学"><a href="#第二阶段：光栅图形学" class="headerlink" title="第二阶段：光栅图形学"></a>第二阶段：光栅图形学</h3><ul><li>算法诞生：图元生成，区域填充，裁剪，反走样，消隐等基本图形概念及其相应算法</li><li>光栅图形学的基础：光栅扫描式图形显示器，该设备是画点设备，可看作是一个点阵单元发生器，可控制每个点阵单元的亮度。</li><li>ACM成立了”the Special Interest Group on Computer Graphics and Interactive Techniques”即“计算机图形和交互技术特别关趣小组”</li><li>1974年，在美国的科罗拉多大学（ColoradoUniversity）召开了第一届SIGGRAPH 年会</li><li>图像软件标准化：CGS（核心图形系统)ISO发布CGI（计算机图形接口标准）、CGM（计算机图形元文件）、GKS（计算机图形核心系统）、PHIGS（程序员层次交互式图形系统）</li><li>真实感图形学萌芽</li></ul><h3 id="第三阶段：真实感图形阶段"><a href="#第三阶段：真实感图形阶段" class="headerlink" title="第三阶段：真实感图形阶段"></a>第三阶段：真实感图形阶段</h3><ul><li>1992年7月，SGI公司发布了OpenGL的1.0版本</li><li>1997年，微软公司发布了DirectX的3.0版本</li><li>20世纪90年代，出现图形处理器（英语：Graphics Processing Unit，缩写：GPU，又称显示核心、视觉处理器、显示芯片），计算机图形学开始具有强大的硬件计算基础。</li><li>1999 年，NVIDIA 发明了GPU，这极大地推动了PC 游戏市场的发展，重新定义了现代计算机图形技术，幵彻底改变了幵行计算。</li><li>造型面片数增加，渲染管线追踪算法实现，渲染表面细节，真实感，渲染实时性</li><li>硬件厂商将光线追踪加速技术、人工智能硬件及可编程着色技术集于同一GPU 中。</li></ul><h1 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h1><hr><p>该文章是学习《计算机图形学-华中科技大学》万琳等老师讲解的课程笔记，里面内容都是来自于这门课程，仅供自己学习使用，如有侵权请联系删除[<a href="mailto:&#49;&#55;&#53;&#x38;&#x35;&#x37;&#53;&#x39;&#x36;&#x39;&#x40;&#113;&#x71;&#x2e;&#99;&#111;&#x6d;">&#49;&#55;&#53;&#x38;&#x35;&#x37;&#53;&#x39;&#x36;&#x39;&#x40;&#113;&#x71;&#x2e;&#99;&#111;&#x6d;</a>]。</p><p>还有老师讲的很好，真心建议自己去看这门课程<a href="https://www.icourse163.org/course/HUST-1003636001">https://www.icourse163.org/course/HUST-1003636001</a>，</p><hr>]]></content>
      
      
      <categories>
          
          <category> code </category>
          
          <category> computer graphics </category>
          
          <category> 计算机图形学_华中科技大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer graphics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[心理学与生活笔记] 03_行为的生物学和进化基础</title>
      <link href="/0ba8edd1b711/03_%E8%A1%8C%E4%B8%BA%E7%9A%84%E7%94%9F%E7%89%A9%E5%AD%A6%E5%92%8C%E8%BF%9B%E5%8C%96%E5%9F%BA%E7%A1%80/"/>
      <url>/0ba8edd1b711/03_%E8%A1%8C%E4%B8%BA%E7%9A%84%E7%94%9F%E7%89%A9%E5%AD%A6%E5%92%8C%E8%BF%9B%E5%8C%96%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="遗传和行为"><a href="#遗传和行为" class="headerlink" title="遗传和行为"></a>遗传和行为</h1><ul><li><p>进化与自然选择<br>  动物种类的变异是自然过程作用的结果，这个过程称为自然选择。<br>  自然选择的理论认为，生物机体适应生存环境，只要这种适应性变异发生了，就会比那些适应性差的个体产生更多后代。久而久之，那些具有适应特征的有机体的数量就会比不具有这些特征的有机体多。用进化论的术语来说，个体的成功与否取决与其后代的数量。 </p><span id="more"></span></li><li><p>基因型和表型<br><img src="https://raw.githubusercontent.com/guitarhgr/imagecloud/master/images/Read/Pshchology/Psychology_and_Life/03_01.png" alt="自然选择如何发生"> </p></li><li><p>人类的进化<br>  在人类进化中，自然选择促进了两大适应性进化：</p><ul><li>两足化：直立行走的能力</li><li>大脑化：脑容量增大</li></ul><p>  两足化和大脑化之后，最重要的人类进化里程碑：语言的出现。<br>  语言是文化进化的基础，而文化进化是通过学习来适应性地应对环境变换的文化趋势。文化进化引起工具制造的重大发展、农业设施的改善以及工业和技术的发展与进步。文化进化还使人类能很快调整并适应环境条件的变化</p></li></ul><h2 id="人类基因型的变异"><a href="#人类基因型的变异" class="headerlink" title="人类基因型的变异"></a>人类基因型的变异</h2><h3 id="基础遗传学"><a href="#基础遗传学" class="headerlink" title="基础遗传学"></a>基础遗传学</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;基因调节身体的生理过程和表型性状的表达(身体构建、体力、智力和许多行为模式)</p><ul><li>遗传学：研究遗传(heredity)机制的学科，即个体从其祖先继承生理和心里特质</li><li>性染色体：决定男性或女性生理特征的基因</li><li>多基因性状：一些特征是由不止一对基因来决定的。</li><li>基因组：染色体上基因以及相关DNA的全部序列</li></ul><h3 id="基因和行为"><a href="#基因和行为" class="headerlink" title="基因和行为"></a>基因和行为</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;进化过程已经使得人类基因型存在相当多的变异，基因型与特殊环境的相互作用产生了人类表型的变异。</p><ul><li>人类行为遗传学(human behavior genetics)：把心理学和遗传学结合起来，探索遗传和行为之间的因果关系，关注于个体差异的根源</li><li>社会生物学(sociobiology)：为社会行为以及人类和其他动物的社会系统提供了进化论的解释</li><li>进化心理学(evolutionary psychology)：将这种进化的解释扩展到人类经验的其他方面。</li></ul><h1 id="神经系统的活动"><a href="#神经系统的活动" class="headerlink" title="神经系统的活动"></a>神经系统的活动</h1><h2 id="神经元"><a href="#神经元" class="headerlink" title="神经元"></a>神经元</h2><p>  专业名词： </p><ul><li>神经元(neuron)：能接收、加工或传递信息到体内其它细胞的细胞，神经元一般只沿一个方向传递信息(树突——&gt;胞体——&gt;轴突——&gt;终扣)。</li><li>树突(dentrites)：接受从感受器或其他神经元发出的刺激。</li><li>胞体(soma)：神经元的细胞体，整合从树突接收的刺激。</li><li>轴突(axon)：自神经元发起的一条突起。</li><li>终扣(terminal buttons)：轴突的末端的一个膨大的球状结构。</li><li>感觉神经元(sensory neurons)：高度特化的细胞，对光线、声音和身体位置非   常敏感，携带来自感受器细胞的信息向内传至中枢神经系统</li><li>运动神经元(motor neurons)：携带来自中枢神经系统的信息向外传至肌肉和腺体。</li><li>中间神经元(internerurons)：从神经元将信息传递到其他中间神经元或运动神经元。</li><li>胶质细胞(glia)：散布于大脑庞大的神经元网络之间的细胞，可达神经元5-10倍之多。主要功能  <ul><li>保持神经元的位置：帮助新生的神经元找到其在脑内的适当位置。</li><li>清理脑内环境：当神经元受损或死亡，附近的胶质细胞就会增生，以清除受损或死亡神经元留下的废物，还能吸收过量的神经递质和神经元间隙的其他物质。</li><li>绝缘：胶质细胞在某类轴突的周围形成一层绝缘的外鞘，称为髓鞘(myelin sheath)。这种脂肪性绝缘大大增加了神经信号的传递速度。</li><li>防止有害物质达到大脑的精密细胞。  </li></ul></li></ul><h2 id="动作电位"><a href="#动作电位" class="headerlink" title="动作电位"></a>动作电位</h2><h3 id="动作电位的产生"><a href="#动作电位的产生" class="headerlink" title="动作电位的产生"></a>动作电位的产生</h3><pre><code>每个神经元将接收到兴奋性输入(excitatory inputs)和抑制性输入(inhibitory inputs)的平衡，前者表达为发放，后者表达为不发放。在神经元内，兴奋性输入在一定时间和空间范围内的正确模式，将导致动作电位的产生，即神经元的发放。</code></pre><h3 id="动作电位的生物化学基础"><a href="#动作电位的生物化学基础" class="headerlink" title="动作电位的生物化学基础"></a>动作电位的生物化学基础</h3><pre><code>    所有神经传导都必须通过称为离子的带电粒子穿过细胞膜的流动产生。细胞膜将细胞内外环境分隔开来的薄膜。神经元内外的液体都含有各种离子：钠离子(Na+)、氯离子(Cl-)、钙离子(Ca2+)和钾离子(K+)，它们带有正电荷或负电荷。细胞膜在维持两种液体成分的适当平衡上具有关键作用。      当细胞不活动或处于静息电位，细胞内钾离子的浓度更高，而细胞外钠离子浓度更高。细胞并不是完美的屏障，它有很小的渗孔，使钠离子可以渗入同时钾离子渗出。为了调整这种情况，细胞膜还有转运机制，可以将钾离子泵入和将钠离子泵出。这些离子泵的成功转运使细胞内液相对细胞外液具有70毫伏的负电压。这就意味着相对与细胞外液而言，细胞内液发生了极化。这一轻微的极化电位称为静息电位(resting potential)，它提供了神经细胞产生动作电位的电位学环境。</code></pre><h3 id="动作电位的性质"><a href="#动作电位的性质" class="headerlink" title="动作电位的性质"></a>动作电位的性质</h3><ul><li>动作电位遵从全或无定律(all-or-none las)：动作电位的大小不受阈</li></ul><h2 id="突出传递"><a href="#突出传递" class="headerlink" title="突出传递"></a>突出传递</h2><h2 id="神经递质及其功能"><a href="#神经递质及其功能" class="headerlink" title="神经递质及其功能"></a>神经递质及其功能</h2><h1 id="生活中的批判性思维：“这是遗传的”是什么意思"><a href="#生活中的批判性思维：“这是遗传的”是什么意思" class="headerlink" title="生活中的批判性思维：“这是遗传的”是什么意思"></a>生活中的批判性思维：“这是遗传的”是什么意思</h1><h1 id="生物学和行为"><a href="#生物学和行为" class="headerlink" title="生物学和行为"></a>生物学和行为</h1><h2 id="对脑的窃听"><a href="#对脑的窃听" class="headerlink" title="对脑的窃听"></a>对脑的窃听</h2><h2 id="神经系统"><a href="#神经系统" class="headerlink" title="神经系统"></a>神经系统</h2><h2 id="脑结构及其功能"><a href="#脑结构及其功能" class="headerlink" title="脑结构及其功能"></a>脑结构及其功能</h2><h2 id="半球功能偏侧化"><a href="#半球功能偏侧化" class="headerlink" title="半球功能偏侧化"></a>半球功能偏侧化</h2><h2 id="内分泌系统"><a href="#内分泌系统" class="headerlink" title="内分泌系统"></a>内分泌系统</h2><h2 id="可塑性和神经发生：变化的大脑"><a href="#可塑性和神经发生：变化的大脑" class="headerlink" title="可塑性和神经发生：变化的大脑"></a>可塑性和神经发生：变化的大脑</h2><h1 id="生活中的心理学：你的大脑如何确定信任与否"><a href="#生活中的心理学：你的大脑如何确定信任与否" class="headerlink" title="生活中的心理学：你的大脑如何确定信任与否"></a>生活中的心理学：你的大脑如何确定信任与否</h1><h1 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h1><hr><p>该文章是学习《社会心理学》的笔记，仅供自己学习使用，如有侵权请联系删除[<a href="mailto:&#49;&#x37;&#53;&#56;&#53;&#x37;&#x35;&#x39;&#x36;&#x39;&#64;&#113;&#x71;&#46;&#99;&#111;&#x6d;">&#49;&#x37;&#53;&#56;&#53;&#x37;&#x35;&#x39;&#x36;&#x39;&#64;&#113;&#x71;&#46;&#99;&#111;&#x6d;</a>]。</p><hr>]]></content>
      
      
      <categories>
          
          <category> read </category>
          
          <category> psychology </category>
          
          <category> psychology and life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> psychology </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[心理学与生活笔记] 02_心理学的研究方法</title>
      <link href="/f6fb50b1bd4b/02_%E5%BF%83%E7%90%86%E5%AD%A6%E7%9A%84%E7%A0%94%E7%A9%B6%E6%96%B9%E6%B3%95/"/>
      <url>/f6fb50b1bd4b/02_%E5%BF%83%E7%90%86%E5%AD%A6%E7%9A%84%E7%A0%94%E7%A9%B6%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="研究过程"><a href="#研究过程" class="headerlink" title="研究过程"></a>研究过程</h1><h2 id="研究的步骤"><a href="#研究的步骤" class="headerlink" title="研究的步骤"></a>研究的步骤</h2><pre><code>1. 初始的观察或问题2. 形成假设3. 设计研究4. 分析数据和得出结论5. 报告研究发现6. 考虑开放的问题7. 对开放的问题再研究 </code></pre><span id="more"></span><h2 id="观察者偏见和操作性定义"><a href="#观察者偏见和操作性定义" class="headerlink" title="观察者偏见和操作性定义"></a>观察者偏见和操作性定义</h2><ul><li>对客观性的挑战：观察者偏见(observer bias)是由于观察者个人的动机和预期导致的错误。通常，人们看见的和听见的只是他们所预期的，而不是事实的本来面目。  </li><li>补救措施：为了使观察者偏见降到最小，研究者依赖于标准化和操作定义  <ul><li>标准化(standardization)意味着在数据的收集阶段使用统一的、一致的程序。</li><li>操作性定义(operational definition)是以测量该概念或决定它是否存在的特定操作或程序来界定一个概念，从而在实验内使含义标准化。  </li></ul></li></ul><h2 id="实验法：备选解释和控制的必要"><a href="#实验法：备选解释和控制的必要" class="headerlink" title="实验法：备选解释和控制的必要"></a>实验法：备选解释和控制的必要</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实验法(experimental methods)：操纵一个自变量来观察其在因变量上产生的效果。</p><h3 id="实验法的客观的挑战和补救措施"><a href="#实验法的客观的挑战和补救措施" class="headerlink" title="实验法的客观的挑战和补救措施"></a>实验法的客观的挑战和补救措施</h3><ul><li><p>客观的挑战：  </p><ul><li>混淆变量(confounding varibale)：并非实验者有意引入到实验情境中确实影响了参与者的行为，并混淆了数据的解释的因素。</li><li>期望效应(expectance effects)：期望是对自己或他人的一种判断，希望自己或他人达到某种目标或满足某种行为预期。有期望而产生的行为结果就是期望效应。</li><li>安慰剂效应(placebo effect)：由于个体对于治疗有效的信念所导致的健康或幸福感的改善。</li></ul></li><li><p>补救措施</p><ol><li><p>控制程序：一些试图使所有变量和条件(除了那些与被验证的假设相关)保持恒定的方法  </p><ul><li>双盲控制(double-blind control)：实验助手和参与者都不知道(双盲)哪些参与者接受了何种处理来消除偏见。</li><li>安慰剂控制(placebo control)：引入一个不进行任何处理的实验条件。  </li></ul></li><li><p>研究设计：为了实施控制条件，研究者决定哪种实验设计最适合他们的目标。  </p><ul><li>被试间设计(between-subjects designs)：参与者被随机分配到实验条件(接受一个或多个实验处理)和控制条件(不接受处理).</li><li>被试内设计(within-subject design)：利用每一个参与者作为研究者自己的控制组。</li></ul></li></ol></li></ul><h2 id="相关法"><a href="#相关法" class="headerlink" title="相关法"></a>相关法</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;相关法是指通过测量来发现事物之间关系的方法。  </p><h3 id="什么时候用？"><a href="#什么时候用？" class="headerlink" title="什么时候用？"></a>什么时候用？</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当想要确定两个变量、特质或者属性之间的关联程度。</p><h3 id="相关系数："><a href="#相关系数：" class="headerlink" title="相关系数："></a>相关系数：</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;确定存在于两个变量之间相关的精确程度。</p><h2 id="阀下影响？"><a href="#阀下影响？" class="headerlink" title="阀下影响？"></a>阀下影响？</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;行为能够受到意识觉知之外的信息——阀下信息的影响。然后经过实验证明其实并没有阀下影响。起作用的是安慰剂效应。</p><h1 id="心理测量"><a href="#心理测量" class="headerlink" title="心理测量"></a>心理测量</h1><h2 id="获得信度和效度"><a href="#获得信度和效度" class="headerlink" title="获得信度和效度"></a>获得信度和效度</h2><ul><li>信度(reliability)：心里测验或实验研究得到的行为数据具有一致性或可靠性。结果具有可靠性是指相似的测验条件下该结果具有可重复性。</li><li> 效度(validity)：研究或测验得到的信息准确地测量了研究者想要测量的心里变量或品质。  </li></ul><h2 id="自我报告法"><a href="#自我报告法" class="headerlink" title="自我报告法"></a>自我报告法</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过言语回答(手写或口述)研究者提出的问题。 </p><h3 id="自我报告法有哪些？"><a href="#自我报告法有哪些？" class="headerlink" title="自我报告法有哪些？"></a>自我报告法有哪些？</h3><ul><li>问卷或调查法：问卷或调查包括一系列的书面的问题，既有事实问题，也有过去或当前行为的问题，还有态度和情感问题。</li><li>访谈：研究者为了获得详细信息与个体进行对话。不想问卷完全标准化，访谈是互动式的。  </li></ul><h3 id="自我报告的局限性"><a href="#自我报告的局限性" class="headerlink" title="自我报告的局限性"></a>自我报告的局限性</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;许多形式的自我报告不适用于前语言期儿童、成人中的文盲者、说其他语言的人、一些心理障碍者以及非人类动物。</p><h2 id="行为测量和观察"><a href="#行为测量和观察" class="headerlink" title="行为测量和观察"></a>行为测量和观察</h2><ul><li>行为观察(behavioral measures)：研究外显行为和可观察、可记录的反应方法。</li><li>自然观察(naturalistic observation)：研究者不改变或不干预自然环境，观察一些自然情境下发生的行为。</li><li>个案观察(case study)：集中在个体或小群体上进行各种测量。</li></ul><h2 id="生活中的心理学：调查研究会影响你的态度吗？"><a href="#生活中的心理学：调查研究会影响你的态度吗？" class="headerlink" title="生活中的心理学：调查研究会影响你的态度吗？"></a>生活中的心理学：调查研究会影响你的态度吗？</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;调查中的问题会对你的态度产生极大的影响。</p><h1 id="人类和动物研究中的伦理问题"><a href="#人类和动物研究中的伦理问题" class="headerlink" title="人类和动物研究中的伦理问题"></a>人类和动物研究中的伦理问题</h1><h2 id="知情同意"><a href="#知情同意" class="headerlink" title="知情同意"></a>知情同意</h2><ul><li>在几乎所有以人类为被试的实验室研究的开始，参与者都要经历知情同意的过程。</li><li>参与者被告知将要经历的程序以及可能的风险和参与的利益。</li><li>提供2中的信息后，要求他们签署同意书，表明他们同意继续。</li><li>要向参与者确保他们的隐私得到保护：   <ul><li>所有的行为记录都会严格保密。 </li><li>公开发表的内容必须得到参与者的同意。</li><li>提前告知参与者他们可以在任何时间停止实验，没有任何处罚。</li><li>留给参与者官方人员的姓名和电话，以供他们有任何不适或疑虑时联系。</li></ul></li></ul><h2 id="风险-收益的评估"><a href="#风险-收益的评估" class="headerlink" title="风险/收益的评估"></a>风险/收益的评估</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;大多数实验不会给参与者带来风险。如果有风险务必把风险降至最低程度，必须把风险告知参与者，并且必须采取适当的防范措施来应对过激反应。公共机构的评审委员会都应谨慎权衡，考虑该研究是否使研究的参与者、科学、社会获益上尤其必要性。</p><h2 id="故意欺骗"><a href="#故意欺骗" class="headerlink" title="故意欺骗"></a>故意欺骗</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;美国心理学协会2002年版的道德原则对于欺骗的使用给出了明确的指导： </p><ul><li>要求参与者在发生身体疼痛或情绪焦虑的可能性上不应被误导。</li><li>要使研究中的欺骗获得批准，研究必须具有充分的科学价值和教育价值。</li><li>研究者必须证明除了欺骗之外没有任何同等有效的程序。</li><li>必须根据研究结论对参与者解释实验中的欺骗。</li><li>参与者必须在欺骗后得到有机会收回自己的数据。</li><li>对于涉及欺骗的研究，评审委员会可以施加强制规定，坚持监督最初提出的程序，或者不批准实验。 </li></ul><h2 id="事后解释"><a href="#事后解释" class="headerlink" title="事后解释"></a>事后解释</h2><ul><li>研究者要尽可能多地提供有关该研究的信息，并且确保参与者没有感到疑惑、心烦或尴尬。</li><li>如果在实验中的某一阶段必须误导参与者，实验者事后要认真向参与者解释欺骗的理由。</li><li>如果参与者觉得他们的数据被误用或他们的权利被侵犯，他们有权收回他们的数据  </li></ul><h2 id="动物研究中的问题"><a href="#动物研究中的问题" class="headerlink" title="动物研究中的问题"></a>动物研究中的问题</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;伦理学家促使研究者贯彻3R原则：</p><ul><li>减少(reduce)所需的动物数量。</li><li>或完全替换(replace)动物的使用。</li><li>改善(refine)研究者的实验步骤，以使疼痛和不适降至最小。</li></ul><h1 id="成为批判性的研究消费者"><a href="#成为批判性的研究消费者" class="headerlink" title="成为批判性的研究消费者"></a>成为批判性的研究消费者</h1><ul><li>避免把相关推论为因果。</li><li>要求关键术语和概念有操作性定义，并对其含义达成一致意见。</li><li>在寻找确定的证据之前，你首先要考虑如何反驳一个理论、假设或信念，因为找一个支持的理由是容易的。</li><li>不要轻信他人提出看似明显的解释，要不断寻找其他可能的解释，尤其在已有的解释会给其提出者带来利益时。</li><li>警惕个人偏见如何歪曲对现实的认识。</li><li>要对复杂问题的简单答案以及复杂效应和问题的单一原因和方案保持怀疑。</li><li>对许多宣称有效的治疗、干预或产品保持质疑，找出其效应的对照基础：与什么相比？</li><li>心智开放，还要保持怀疑态度：必须意识到，大多数结论是尝试性的、非确定的；寻找新证据以减少你的不确定感，同时对变化和修正保持开放态度。</li><li>挑战那些在做出结论时使用个人观点取代证据且不接受建设性批评的权威。</li></ul><h2 id="生活中的批判性思维：-为什么数字技术如此重要"><a href="#生活中的批判性思维：-为什么数字技术如此重要" class="headerlink" title="生活中的批判性思维： 为什么数字技术如此重要"></a>生活中的批判性思维： 为什么数字技术如此重要</h2><ul><li>统计呈现的形式对人们对信息作何行动有很大的影响。</li><li>数字技术能更好额较少受到统计呈现形式的影响。</li></ul><h1 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h1><hr><p>该文章是学习《社会心理学》的笔记，仅供自己学习使用，如有侵权请联系删除[<a href="mailto:&#x31;&#x37;&#53;&#x38;&#53;&#55;&#x35;&#57;&#x36;&#57;&#64;&#x71;&#x71;&#x2e;&#99;&#x6f;&#x6d;">&#x31;&#x37;&#53;&#x38;&#53;&#55;&#x35;&#57;&#x36;&#57;&#64;&#x71;&#x71;&#x2e;&#99;&#x6f;&#x6d;</a>]。</p><hr>]]></content>
      
      
      <categories>
          
          <category> read </category>
          
          <category> psychology </category>
          
          <category> psychology and life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> psychology </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[心理学与生活笔记] 01_生活中的心理学</title>
      <link href="/a10d342803f0/01_%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E5%BF%83%E7%90%86%E5%AD%A6/"/>
      <url>/a10d342803f0/01_%E7%94%9F%E6%B4%BB%E4%B8%AD%E7%9A%84%E5%BF%83%E7%90%86%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="心理学为何独居特色？"><a href="#心理学为何独居特色？" class="headerlink" title="心理学为何独居特色？"></a>心理学为何独居特色？</h1><h2 id="心理学定义"><a href="#心理学定义" class="headerlink" title="心理学定义"></a>心理学定义</h2><p>   关于个体的行为以及心智过程的科学研究。</p><span id="more"></span><h2 id="心理学的目标"><a href="#心理学的目标" class="headerlink" title="心理学的目标"></a>心理学的目标</h2><ul><li>描述发生的事情：对行为进行准确的观察。</li><li>解释发生的事情：有意地超越可观察到的现象。</li><li>预测将要发生的事情：表述一个特定行为将要发生的可能性和一种特定关系将被发现的可能性。</li><li>控制发生的事情：支配行为的发生或不发生——启动行为，维持行为，停止行为，并且影响行为的形式、强度或发生频率。</li><li>生活中的批判性思维：对“我应该相信什么和做什么”做出理性的决策。</li></ul><h1 id="现代心理学的发展"><a href="#现代心理学的发展" class="headerlink" title="现代心理学的发展"></a>现代心理学的发展</h1><h2 id="心理学的历史根基"><a href="#心理学的历史根基" class="headerlink" title="心理学的历史根基"></a>心理学的历史根基</h2><ul><li>公元前4世纪和5世纪：柏拉图(公元前427-公元前347)和亚里士多德(公元前384-公元前322)提出的基本问题：心智如何运作？自由意志的本质是什么？公民个体与其城邦或国家的关系是什么？ </li><li>17世纪：约翰·浩克(John Locke, 1632-1704)阐明了人们的心智生来是白板，心智通过世界上的经验来获取信息。</li><li>18世纪：伊曼努尔·康德(Immanuel Kant, 1724-1804)发展了观点人们生来便具有心理结构，对他们在世界上的经验产生限制。</li><li>1879年：威廉·冯特(Wilhelm Wundt, 1832-1920)在德国建立了第一个正式的实验心理学实验室，并完成了一系列研究并出版了《生理心理学原理》的第一版。</li><li>1892年：爱德华·铁钦纳(Edward Titchener, 1867-1927)随冯特学习之后成为了美国第一批心理学家之一，并在康奈尔大学建立了一个实验室</li><li>1892年：威廉·詹姆士(William James, 1842-1910)撰写了一部两卷书《心理学原理》，这部著作被许多专家认为是有史以来最重要的心理学教科书。</li><li>1892年：斯坦利·霍尔(G.Stanley Hall)创立了美国心理学协会(American Psychological Association, APA)</li><li>1900年：北美已经有了40余个心理学实验室。</li><li>1908年：赫尔曼·艾宾浩斯(Hermann Ebbinghaus, 1850-1909)写道：“心理学有着漫长的过去，但只有短暂的历史”。  </li></ul><h2 id="作为先去研究者的女性"><a href="#作为先去研究者的女性" class="headerlink" title="作为先去研究者的女性"></a>作为先去研究者的女性</h2><ul><li>玛丽·惠顿·卡尔金斯(Mary Whiton Calkins, 1863-1930)毕业于哈弗，师从威廉·詹姆士，建立了美国第一批心理学实验室之一，并且创造了研究记忆的重要工具。1905年，她成为了美国心理学协会(APA)的第一位女性主席。</li><li>玛格丽特·沃什布恩(Margaret Washburn, 1871-1939)毕业于康奈尔大学，成为第一位获得心理学博士学位的女性。写了一部有影响力的早期教科书《动物心理》。这本书总结了各种动物物种中关于感觉、学习和记忆的研究。1921年，沃什布恩成为了美国心理学协会的第二位女性领导者。</li><li>海伦·汤普森·伍利(Helen Thompson Wooley, 1874-1947)最早完成了考察性别差异的一些研究。</li><li>丽塔·斯塔特·霍林沃斯(Leta Stetter Hollingworth, 1886-1939)收到伍利启发。利用研究数据挑战关于性别差异的主张。  </li></ul><h2 id="心理学的观点"><a href="#心理学的观点" class="headerlink" title="心理学的观点"></a>心理学的观点</h2><ul><li>心理动力学观点：行为是有强大的内部力量驱使或激发。</li><li>行为主义观点：寻求理解特定的环境刺激如何控制特定类型的行为。</li><li>人本主义观点：人是具有能动性的动物，本性善良而且具有选择能力。</li><li>认知观点：人的思维以及所有的认识过程——注意、思考、记忆和理解。</li><li>生物学观点：经验和行为在很大程度上被理解为在神经细胞内部及之间发生的化学和电活动。</li><li>进化论观点：心理能力和身体能力一样，经过了几百万年的进化以达到特定的适应性目标。</li><li>社会文化观点：态度和行为的跨文化模式。</li></ul><h1 id="心理学家们做些什么？"><a href="#心理学家们做些什么？" class="headerlink" title="心理学家们做些什么？"></a>心理学家们做些什么？</h1><ol><li><p>临床心理学家、咨询心理学家、社区心理学家：<br>研究心理障碍的起源，评估治疗方案；为心理障碍及其他个人调适问题提供诊断和治疗。  </p></li><li><p>康复心理学家：<br>为病人或残疾人提供评估和咨询；为患者、看护者、雇员和社区成员提供应对策略和教育。  </p></li><li><p>生物心理学家、精神药理学家：<br>研究行为、感受和心理过程的生物化学基础。  </p></li><li><p>实验心理学家、行为分析师：<br>采用实验室实验，通常以动物为实验对象，研究学习、感觉、知觉、情绪和动机的基本过程。</p></li><li><p>认知心理学家、认知科学家：<br>研究记忆、感知、推理、问题解决、决策和语言使用等心理过程。  </p></li><li><p>人格心理学家、行为遗传学家：<br>开发测试和发展理论以理解人格和行为上的差异；研究遗传和环境对这些差异的影响。</p></li><li><p>社会心理学家：<br>研究人们在社会群体中如何发挥作用，以及人们选择、解释及记忆社会信息的过程。</p></li><li><p>发展心理学家：<br>研究个体一生在生理、认知和社会功能上发生的变化；研究遗传和环境对这些变化的影响。  </p></li><li><p>工业组织心理学家、工效心理学家：<br> 研究在一般工作场所或特定工作上影响表现和士气的因素；将这些观点运用于工作场所。  </p></li><li><p>教育心理学家、学校心理学家：<br>研究如何改进学习过程的各个方面；协助设计学校课程、教学训练项目和儿童呵护项目。  </p></li><li><p>健康心理学家：<br>研究不同的生活方式如何影响身体健康；设计和评估预防方案以帮助人们改变有害健康的行为，以及如何应对压力。  </p></li><li><p>司法心理学家：<br>在执法领域，将心理学知识运用于人类问题上。  </p></li><li><p>运动心理学家：<br>评估运动员的表现；运用动机、认知和行为的原理来帮助他们获得最高的表现水平。  </p></li><li><p>定量心理学家、心理测量师：<br>开发和评估新的统计方法；构建和验证测量工具。  </p></li><li><p>数学心理学家：<br>开发数学公式用以精确地预测行为和检验比较不同的心理学理论。</p></li></ol><h1 id="如何学习阅读书？"><a href="#如何学习阅读书？" class="headerlink" title="如何学习阅读书？"></a>如何学习阅读书？</h1><h2 id="学习策略："><a href="#学习策略：" class="headerlink" title="学习策略："></a>学习策略：</h2><ol><li>留出足够多的时间来完成阅读作业并复习课堂笔记。</li><li>记录你学习这门课的时间。</li><li>成为积极的参与者。</li><li>间隔性的学习。</li><li>以学习为中心。  <h2 id="学习技巧-RQ4R-："><a href="#学习技巧-RQ4R-：" class="headerlink" title="学习技巧(RQ4R)："></a>学习技巧(RQ4R)：</h2></li><li>预习(Preview)：浏览以便对每章的内容有基本的把握。</li><li>问题(Questions)：阅读每一部分时都要提问。</li><li>阅读(Read)：仔细阅读课文的内容直到你能回答自己提出的问题。</li><li>思考(Reflect)：在阅读课文过程中，努力将这些材料与已有的知识联系起来。</li><li>重述(Recite)：在阅读和思考每节后，试着尽可能详细地回忆课本的内容。</li><li>复习(Review)：在阅读完整个章节后，复习关键点。</li></ol><h1 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h1><hr><p>该文章是学习《社会心理学》的笔记，仅供自己学习使用，如有侵权请联系删除[<a href="mailto:&#x31;&#55;&#x35;&#56;&#x35;&#x37;&#x35;&#57;&#54;&#x39;&#64;&#113;&#x71;&#x2e;&#x63;&#111;&#109;">&#x31;&#55;&#x35;&#56;&#x35;&#x37;&#x35;&#57;&#54;&#x39;&#64;&#113;&#x71;&#x2e;&#x63;&#111;&#109;</a>]。</p><hr>]]></content>
      
      
      <categories>
          
          <category> read </category>
          
          <category> psychology </category>
          
          <category> psychology and life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> psychology </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
